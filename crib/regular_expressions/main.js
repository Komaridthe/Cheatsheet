"use strict"
let { warn } = console;

warn("======== Введение: шаблоны и флаги ========");
/*
* Регулярные выражения
 Существует два синтаксиса для создания регулярного выражения.
 · «Длинный» синтаксис:
regexp = new RegExp("шаблон", "флаги");
 · И короткий синтаксис, использующий слеши "/":
regexp = /шаблон/; - без флагов
regexp = /шаблон/gmi; - с флагами gmi

 Основная разница между этими двумя способами создания заключается в том, что слеши /.../ не допускают никаких вставок переменных
(наподобие возможных в строках через ${...}).
 Слеши используются, когда мы на момент написания кода точно знаем, каким будет регулярное выражение – и это большинство ситуаций.
А new RegExp – когда мы хотим создать регулярное выражение «на лету» из динамически сгенерированной строки, например:
*/
// let tag = prompt("Какой тег вы хотите найти?", "h2");
// let regexp = new RegExp(`<${tag}>`); // то же, что и /<h2>/ при ответе "h2" на prompt выше

/*
* Флаги
Регулярные выражения могут иметь флаги, которые влияют на поиск. Их всего шесть:
 · i - С этим флагом поиск не зависит от регистра: нет разницы между A и a.
 · g - С этим флагом поиск ищет все совпадения, без него – только первое.
 · m - Многострочный режим.
 · s - Включает режим «dotall», при котором точка . может соответствовать символу перевода строки \n.
 · u - Включает полную поддержку юникода. Флаг разрешает корректную обработку суррогатных пар.
 · y - Режим поиска на конкретной позиции в тексте.


* Поиск: str.match
 Использование регулярных выражений интегрировано в методы строк.
Метод str.match(regexp) для строки str возвращает совпадения с регулярным выражением regexp.
 У него есть три режима работы:
 1) Если у регулярного выражения есть флаг g, то он возвращает массив всех совпадений:
*/
let strOne = "Любо, братцы, любо!";
console.log(strOne.match(/любо/gi)); // Любо,любо (массив из 2х подстрок-совпадений) из-за флага i !
/*
 2) Если такого флага нет, то возвращает только первое совпадение в виде массива, в котором по индексу 0 находится совпадение,
и есть свойства с дополнительной информацией о нём:
*/
let strTwo = "Любо, братцы, любо!";
let result = strTwo.match(/любо/i); // без флага g

console.log(result[0]); // Любо (первое совпадение)
console.log(result.length); // 1
// Дополнительная информация:
console.log(result.index);  // 0 (позиция совпадения)
console.log(result.input);  // Любо, братцы, любо! (исходная строка)
/*
 3) Если совпадений нет, то, вне зависимости от наличия флага g, возвращается null.
! Это важный нюанс. Если об этом забыть, можно легко допустить ошибку !
*/
let matches = "JavaScript".match(/HTML/); // = null
try {
	!matches.length // Ошибка: у null нет свойства length
} catch (e) {
	console.log(e);
}
// Если нужно, чтобы результатом всегда был массив, можно написать так:
let matchesErr = "JavaScript".match(/HTML/) || []; // или ?? []
if (!matchesErr.length) {
	console.log("Совпадений нет"); // теперь работает
}

/*
* Замена: str.replace
Метод str.replace(regexp, replacement) заменяет совпадения с regexp в строке str на replacement (все, если есть флаг g, иначе только первое).
*/
console.log("We will, we will".replace(/we/i, "I")); // I will, we will
console.log("We will, we will".replace(/we/ig, "I")); // I will, I will
/*
* В строке замены replacement мы можем использовать специальные комбинации символов для вставки фрагментов совпадения:

Спецсимволы	        \ Действие в строке замены
____________________\________________________________________________________________________________________________
$&	                 \ вставляет всё найденное совпадение
--------------------\------------------------------------------------------------------------------------------------
$`	                 \ вставляет часть строки до совпадения
--------------------\------------------------------------------------------------------------------------------------
$'	                 \ вставляет часть строки после совпадения
--------------------\------------------------------------------------------------------------------------------------
$n	                 \ если n это 1-2 значное число, вставляет содержимое n-й скобочной группы регулярного выражения
--------------------\------------------------------------------------------------------------------------------------
$<name>	           \ вставляет содержимое скобочной группы с именем name
--------------------\------------------------------------------------------------------------------------------------
$$	                 \ вставляет символ "$"
--------------------\------------------------------------------------------------------------------------------------
*/
console.log("Люблю HTML".replace(/HTML/, "$& и JavaScript")); // Люблю HTML и JavaScript

/*
* Проверка: regexp.test
Метод regexp.test(str) проверяет, есть ли хоть одно совпадение, если да, то возвращает true, иначе false.
*/
let strTree = "Я ЛюБлЮ JavaScript";
let regexpTwo = /люблю/i;
console.log(regexpTwo.test(strTree)); // true


warn("======== Символьные классы ========");
/*
* Символьный класс – это специальное обозначение, которое соответствует любому символу из определённого набора.
 Рассмотрим на примере задачи – у нас есть номер телефона вида "+7(903)-123-45-67", и нам нужно превратить его в строку
только из чисел: 79031234567.
 Класс «цифра» обозначается как \d и в регулярном выражении и соответствует «любой одной цифре».
Первая цифра в номере телефона:
*/
let num = "+7(903)-123-45-67";
let ergNum = /\d/;
console.log(num.match(ergNum)); // '7', index: 1, imput: ...
// Добавив флаг g, найдутся все цифры:
let ergNumTwo = /\d/g;
console.log(num.match(ergNumTwo)); // массив совпадений: 7,9,0,3,1,2,3,4,5,6,7
// Или сразу чисто цифровой номер телефона
console.log(num.match(ergNumTwo).join('')); // 79035419441
/*
* Основные символьные классы
 · \d («d» от английского «digit» означает «цифра») - Цифра: символ от 0 до 9.
 · \s («s»: от английского «space» – «пробел») - Пробельные символы: включает в себя символ пробела, табуляции \t, перевода строки \n
  и некоторые другие редкие пробельные символы, обозначаемые как \v, \f и \r.
 · \w («w»: от английского «word» – «слово») - Символ «слова», а точнее – буква латинского алфавита или цифра или подчёркивание _.
  Нелатинские буквы не являются частью класса \w, то есть буква русского алфавита не подходит.

 Для примера, \d\s\w обозначает «цифру», за которой идёт пробельный символ, а затем символ слова, например 1 a.

! Регулярное выражение может содержать как обычные символы, так и символьные классы.
 Например, CSS\d соответствует строке CSS с цифрой после неё:
*/
let strCss = "Есть ли стандарт CSS4?";
let regCss = /CSS\d/;
console.log(strCss.match(regCss)); // 'CSS4'...
// Также можно использовать несколько символьных классов:
console.log("I love HTML5!".match(/\s\w\w\w\w\d/)); // ' HTML5'...

/*
* Обратные символьные классы
 Для каждого символьного класса существует «обратный класс», обозначаемый той же буквой, но в верхнем регистре.
«Обратный» означает, что он соответствует всем другим символам, например:
 · \D - Не цифра: любой символ, кроме \d, например буква.
 · \S - Не пробел: любой символ, кроме \s, например буква.
 · \W - Любой символ, кроме \w, то есть не буквы из латиницы, не знак подчёркивания и не цифра. В частности, русские буквы принадлежат этому классу.

 Альтернативный(более короткий) путь в примере с телефоном – найти нецифровые символы \D и удалить их из строки:
*/
console.log(num.replace(/\D/g, "")); // 79031234567

/*
* Точка – это любой символ
Точка . – это специальный символьный класс, который соответствует «любому символу, кроме новой строки».
*/
console.log("Ю".match(/./)); // 'Ю

// Или в середине регулярного выражения:
let regDot = /CS.4/;
console.log("CSS4".match(regDot)); // CSS4
console.log("CS-4".match(regDot)); // CS-4
console.log("CS 4".match(regDot)); // CS 4 (пробел тоже является символом)

// ! Точка означает «любой символ», но не «отсутствие символа». Там должен быть какой-либо символ, чтобы соответствовать условию поиска:
console.log("CS4".match(regDot)); // null
/*
! Точка будет буквально любой символ, с флагом «s»
 Точка не соответствует символу новой строки \n. То есть, регулярное выражение A.B будет искать символ A и затем B, с любым символом между ними,
кроме перевода строки \n:
*/
console.log("A\nB".match(/A.B/)); // null
//  Как раз для этого нужен флаг s. Если регулярное выражение имеет его, то точка . соответствует буквально любому символу:
console.log("A\nB".match(/A.B/s)); // A\nB

/*
* О пробелах
 Строки 1-5 и 1 - 5 практически идентичны. Но если регулярное выражение не учитывает пробелы, оно может не сработать.
*/
console.log("1 - 5".match(/\d-\d/)); // null, нет совпадения!
// Исправим это, добавив пробелы в регулярное выражение \d - \d:
console.log("1 - 5".match(/\d - \d/)); // 1 - 5
// Или так:
console.log("1 - 5".match(/\d\s-\s\d/)); // 1 - 5


warn("=== Юникод: флаг 'u' и класс \p{...} ===");
/*
 В JavaScript для строк используется кодировка Юникод. Обычно символы кодируются с помощью 2 байтов,
что позволяет закодировать максимум 65536 символов. Этого диапазона не хватает для того, чтобы закодировать все символы.
Поэтому некоторые редкие символы кодируются с помощью 4 байтов, например 𝒳 (математический X) или 😄 (смайлик), некоторые иероглифы, и т.п.

 С этим есть свои нюансы, например, свойство length считает, что здесь два символа:
*/
console.log('😄'.length); // 2
console.log('𝒳'.length); // 2
// Свойство length воспринимает 4-байтовый символ как два символа по 2 байта. (так называемая «суррогатная пара»)
/*
! Регулярные выражения также по умолчанию воспринимают 4-байтные «длинные символы» как пары 2-байтных.
! Но у них есть специальный флаг u, который исправляет эту проблему. 


* Юникодные свойства \p{…}
! Несмотря на то, что это часть стандарта с 2018 года, юникодные свойства не поддерживаются в Firefox до 78 версии и в Edge до 79 версии.
 Существует библиотека XRegExp, которая реализует «расширенные» регулярные выражения с кросс-браузерной поддержкой юникодных свойств.

 Каждому символу в кодировке Юникод соответствует множество свойств. Например, свойство Letter у символа означает, что это буква какого-то алфавита,
причём любого. А свойство Number означает, что это цифра – арабская или китайская, и т.п, на каком-то из языков.
 В регулярном выражении можно искать символ с заданным свойством, указав его в \p{…}. Для таких регулярных выражений обязательно использовать флаг u.
Например, \p{Letter} обозначает букву в любом языке. Также можно использовать запись \p{L}, так как L – это псевдоним Letter.
*/
let strL = "A ბ ㄱ";
console.log(strL.match(/\p{L}/gu)); // ['A','ბ','ㄱ']
console.log(strL.match(/\p{L}/g)); // null (ничего не нашло, так как нет флага "u")
/*
* Основные категории символов и их подкатегории:
 · Буквы L:
  · в нижнем регистре Ll,
  · модификаторы Lm,
  · заглавные буквы Lt,
  · в верхнем регистре Lu,
  · прочие Lo.
 · Числа N:
  · десятичная цифра Nd,
  · цифры обозначаемые буквами (римские) Nl,
  · прочие No.
 · Знаки пунктуации P:
  · соединители Pc,
  · тире Pd,
  · открывающие кавычки Pi,
  · закрывающие кавычки Pf,
  · открывающие скобки Ps,
  · закрывающие скобки Pe,
  · прочее Po.
 · Отметки M (например, акценты):
  · двоеточия Mc,
  · вложения Me,
  · апострофы Mn.
 · Символы S:
  · валюты Sc,
  · модификаторы Sk,
  · математические Sm,
  · прочие So.
 · Разделители Z:
  · линия Zl,
  · параграф Zp,
  · пробел Zs.
 · Прочие C:
  · контрольные Cc,
  · форматирование Cf,
  · не назначенные Cn,
  · для приватного использования Co,
  · суррогаты Cs.

 Есть и другие категории – производные, например:
 · Alphabetic (Alpha), включающая в себя буквы L, плюс «буквенные цифры» Nl (например Ⅻ – символ для римской записи числа 12),
  и некоторые другие символы Other_Alphabetic (OAlpha).
 · Hex_Digit включает символы для шестнадцатеричных чисел: 0-9, a-f.
 · И так далее.

*Пример: шестнадцатеричные числа
 Поищем шестнадцатеричные числа, записанные в формате xFF, где вместо F может быть любая шестнадцатеричная цифра (0…1 или A…F).
Шестнадцатеричная цифра может быть обозначена как \p{Hex_Digit}:
*/
let regeFF = /x\p{Hex_Digit}\p{Hex_Digit}/u;
console.log("число: xAF".match(regeFF)); // xAF
/*
* Пример: китайские иероглифы
 В Юникоде есть свойство Script (система написания), которое может иметь значения Cyrillic (Кириллическая), Greek (Греческая),
Arabic (Арабская), Han (Китайская) и так далее, здесь полный список.
 Для поиска символов в нужной системе мы должны установить Script=<значение>, например для поиска кириллических букв: \p{sc=Cyrillic},
для китайских иероглифов: \p{sc=Han}, и так далее:
*/
let regeHan = /\p{sc=Han}/gu; // вернёт китайские иероглифы
let strHun = `Hello Привет 你好 123_456`;
console.log(strHun.match(regeHan)); // 你,好
/*
* Пример: валюта
Символы, обозначающие валюты, такие как $, €, ¥ и другие, имеют свойство \p{Currency_Symbol}, короткая запись \p{Sc}.
*/
let regeSc = /\p{Sc}\d/gu;
let strSc = `Цены: $2, €1, ¥9`;
console.log(strSc.match(regeSc)); // $2,€1,¥9


warn("=== Якоря: начало строки ^ и конец $ ===");
/*
 У символов каретки ^ и доллара $ есть специальные значения в регулярных выражениях. Они называются «якоря» (anchors).
Каретка ^ означает совпадение с началом текста, а доллар $ – с концом.
*/
let strMary = "Mary had a little lamb";
console.log(/^Mary/.test(strMary)); // true (Шаблон ^Mary означает: «начало строки, затем Mary»)

let strSnow = "it's fleece was white as snow";
console.log(/snow$/.test(strSnow)); // true
/*
 В конкретно этих случаях мы могли бы использовать и методы строк startsWith/endsWith.
Регулярные выражения следует применять, когда нужна проверка сложнее.

* Проверка на полное совпадение
 Оба якоря вместе ^...$ часто используются для проверки, совпадает ли строка с шаблоном полностью. Например, чтобы определить,
в правильном ли формате пользователь ввёл данные. На языке регулярных выражений это \d\d:\d\d:
*/
let goodInput = "12:34";
let badInput = "12:345";
let regTime = /^\d\d:\d\d$/;
console.log(regTime.test(goodInput)); // true
console.log(regTime.test(badInput)); // false


warn("=== Многострочный режим якорей ^ $, флаг 'm' ====");
/*
!  Многострочный режим включается флагом m.
! Он влияет только на поведение ^ и $.
! В многострочном режиме они означают не только начало/конец текста, но и начало/конец каждой строки в тексте.

* Поиск в начале строки ^
 В примере ниже текст состоит из нескольких строк. Шаблон /^\d/gm берёт цифру с начала каждой строки:
*/
let strWithM = `1е место: Винни
2е место: Пятачок
3е место: Слонопотам`;
console.log(strWithM.match(/^\d/gm)); // ['1', '2', '3']
// Без флага m было бы найдено только первое число:
let strWithoutM = `1е место: Винни
2е место: Пятачок
3е место: Слонопотам`;
console.log(strWithoutM.match(/^\d/g)); // ['1']

/*
* Поиск в конце строки $
 Символ доллара $ ведёт себя аналогично. Регулярное выражение \d$ ищет последнюю цифру в каждой строке
*/
let strWithMTwo = `Винни: 1
Пятачок: 2
Слонопотам: 3`;
console.log(strWithMTwo.match(/\d$/gm)); // ['1', '2', '3']
// Без флага m якорь $ обозначал бы конец всей строки, и была бы найдена только последняя цифра.

/*
* Ищем \n вместо ^ $
Для того, чтобы найти конец строки, можно использовать не только якоря ^ и $, но и символ перевода строки \n.
*/
let strN = `Винни: 1
Пятачок: 2
Слонопотам: 3`;
console.log(strN.match(/\d\n/g)); // ['1\n', '2\n']
/*
 Совпадений теперь два, а не три. Это потому, что после 3 нет перевода строки (а конец текста, подходящий под $ – есть).
И теперь в каждое найденное совпадение входит символ перевода строки \n. \n – символ и входит в результат.
! Так что \n в шаблоне используется, когда нам нужен сам символ перевода строки в результате, а якоря – когда хотим найти что-то в начале/конце строки.
*/


warn("======== Граница слова: \b ========");
/*
* Граница слова \b – проверка, как ^ и $.
 Есть три вида позиций, которые являются границами слова:
 · Начало текста, если его первый символ \w.
 · Позиция внутри текста, если слева находится \w, а справа – не \w, или наоборот.
 · Конец текста, если его последний символ \w.
 Регулярное выражение \bJava\b будет найдено в строке Hello, Java!, где Java – отдельное слово, но не будет найдено в строке Hello, JavaScript!.
*/
console.log("Hello, Java!".match(/\bJava\b/)); // Java
console.log("Hello, JavaScript!".match(/\bJava\b/)); // null
// Восклицательный знак не является «символом слова» \w
console.log("Hello, Java!".match(/\bHello\b/)); // Hello
console.log("Hello, Java!".match(/\bJava\b/));  // Java
console.log("Hello, Java!".match(/\bHell\b/));  // null (нет совпадения)
console.log("Hello, Java!".match(/\bJava!\b/)); // null (нет совпадения)
/*
* Можно использовать \b не только со словами, но и с цифрами.
Например, регулярное выражение \b\d\d\b ищет отдельно стоящие двузначные числа.
*/
console.log("1 23 456 78".match(/\b\d\d\b/g)); // 23,78
console.log("12,34,56".match(/\b\d\d\b/g)); // 12,34,56

//! Граница слова \b не работает для алфавитов, не основанных на латинице


warn("======== Экранирование, специальные символы ========");
/*
! Специальные символы [ ] \ ^ $ . | ? * + ( )


* Экранирование символов
 Допустим, необходимо найти буквально точку. Не «любой символ», а именно точку.
Чтобы использовать специальный символ как обычный, добавьте к нему обратную косую черту: \..
*/
console.log("Глава 5.1".match(/\d\.\d/)); // 5.1 (совпадение!)
console.log("Глава 511".match(/\d\.\d/)); // null ("\." - ищет обычную точку)

// Круглые скобки также являются специальными символами, поэтому, если нам нужно использовать именно их, нужно указать \(.
console.log("function g()".match(/g\(\)/)); // "g()"

// Обратная косая черта \, это специальный символ как в обычных строках, так и в регулярных выражениях, поэтому нужно удвоить её.
console.log("1\\2".match(/\\/)); // '\\' ?? должна была быть одна черта..)

/*
* Косая черта
Символ косой черты '/', так называемый «слэш», не является специальным символом, но в JavaScript он используется для открытия и закрытия
регулярного выражения: /...шаблон.../, поэтому его нужно экранировать.
*/
console.log("/".match(/\//)); // '/'

// Если не использовать короткую запись /.../, а new RegExp, тогда экранировать косую черту не нужно:
console.log("/".match(new RegExp("/"))); // '/'

/*
* new RegExp
 При создании регулярного выражения с помощью new RegExp, не нужно учитывать /, но нужно другое экранирование.
Например, такой поиск не работает:
*/
let regexp = new RegExp("\d\.\d");
console.log("Глава 5.1".match(regexp)); // null
/*
 Строковые кавычки «съедают» символы обратной косой черты для себя, например:
 · \n – становится символом перевода строки,
 · \u1234 – становится символом Юникода с указанным номером,
 · …А когда нет особого значения: как например для \d или\z, обратная косая черта просто удаляется.
 Вот как воспринимается строка «\d.\d»:
*/
console.log("\d\.\d"); // d.d
/*
! Таким образом, new RegExp получает строку без обратной косой черты.
 Чтобы исправить это, нужно удвоить обратную косую черту, потому что строковые кавычки превращают \\ в \:
*/
let regSpStr = "\\d\.\\d";
console.log(regSpStr); // \d\.\d

let regexpSp = new RegExp(regSpStr);
console.log("Глава 5.1".match(regexpSp)); // 5.1


warn("======== Наборы и диапазоны [...] ========");
/*
! Несколько символов или символьных классов в квадратных скобках […] означают «искать любой символ из заданных».

* Наборы
 [eao] означает любой из 3-х символов: 'a', 'e' или 'o'.
Например, найти [т или х], после которых идёт "оп"
*/
console.log("Топ хоп".match(/[тх]оп/gi)); // ['Топ', 'хоп']

/*
* Диапазоны
 Ещё квадратные скобки могут содержать диапазоны символов.
К примеру, [a-z] соответствует символу в диапазоне от a до z, или [0-5] – цифра от 0 до 5.
 В примере ниже ищем "x", за которым следуют две цифры или буквы от A до F:
*/
console.log("Exception 0xAF".match(/x[0-9A-F][0-9A-F]/g)); // ['xAF']
/*
 Если нужно найти буквы и в верхнем и в нижнем регистре, то добавляем ещё диапазон a-f: [0-9A-Fa-f]. Или ставиь у регулярного выражения флаг i.
Если надо найти «символ слова» \w или дефис -, то набор будет: [\w-].
Можно использовать и несколько классов вместе, например [\s\d] означает «пробельный символ или цифра».

* Символьные классы – не более чем сокращение для наборов символов.
 · \d – то же самое, что и [0-9],
 · \w – то же самое, что и [a-zA-Z0-9_],
 · \s – то же самое, что и [\t\n\v\f\r ], плюс несколько редких пробельных символов Юникода.


* Многоязычный аналог \w
 Так как символьный класс \w является всего лишь сокращением для [a-zA-Z0-9_], он не найдёт китайские иероглифы, кириллические буквы и т.п.
! Вот его многоязычный аналог - [\p{Alpha}\p{M}\p{Nd}\p{Pc}\p{Join_C}].
 · Alphabetic (Alpha) – для букв,
 · Mark (M) – для акцентов,
 · Decimal_Number (Nd) – для цифр,
 · Connector_Punctuation (Pc) – для символа подчёркивания '_' и подобных ему,
 · Join_Control (Join_C) – два специальных кода 200c и 200d, используемые в лигатурах, например, арабских.
*/
let analogW = /[\p{Alpha}\p{M}\p{Nd}\p{Pc}\p{Join_C}]/gu;
let strAn = `Hi 你好 12`;
console.log(strAn.match(analogW)); // ['H', 'i', '你', '好', '1', '2'] - найдены все буквы и цифры

/*
* Исключающие диапазоны
 Они обозначаются символом каретки ^ в начале диапазона и соответствуют любому символу за исключением заданных[^…].
Например:
 · [^aeyo] – любой символ, за исключением 'a', 'e', 'y' или 'o'.
 · [^0-9] – любой символ, за исключением цифры, то же, что и \D.
 · [^\s] – любой непробельный символ, то же, что и \S.
 Пример ниже ищет любые символы, кроме латинских букв, цифр и пробелов:
 */
console.log("alice15@gmail.com".match(/[^\d\sA-Z]/gi)); // ['@', '.']

/*
* Экранирование внутри […]
 В квадратных скобках большинство специальных символов можно использовать без экранирования (их можно экранировать если оч хочется):
 · Символы . + ( ) не нужно экранировать никогда.
 · Тире - не надо экранировать в начале или в конце (где оно не задаёт диапазон).
 · Символ каретки ^ нужно экранировать только в начале (где он означает исключение).
 · Закрывающую квадратную скобку ], если нужен именно такой символ, экранировать нужно.
! Разрешены без экранирования все специальные символы, кроме случаев, когда они означают что-то особое в наборах.
 В примере ниже регулярное выражение [-().^+] ищет один из символов -().^+:
*/
let regeNonEc = /[-().^+]/g;
console.log("1 + 2 - 3".match(regeNonEc)); // ['+', '-']

/*
* Наборы и флаг «u»
 Если в наборе есть суррогатные пары, для корректной работы обязательно нужен флаг u.
Например, ищем шаблон [𝒳𝒴] в строке 𝒳:
*/
console.log('𝒳'.match(/[𝒳𝒴]/)); // ['\uD835', index: 0, input: '𝒳', groups: undefined]
/*
 Движок регулярных выражений думает, что [𝒳𝒴] – это не два, а четыре символа:
 1 - левая половина от 𝒳 (1),
 2 - правая половина от 𝒳 (2),
 3 - левая половина от 𝒴 (3),
 4 - правая половина от 𝒴 (4).
 То есть в примере выше ищется и выводится только левая половина от 𝒳.
Если добавить флаг u, то всё будет в порядке:
*/
console.log('𝒳'.match(/[𝒳𝒴]/u)); // ['𝒳', index: 0, input: '𝒳', groups: undefined]

// Аналогичная ситуация произойдёт при попытке искать диапазон: [𝒳-𝒴]
// console.log('𝒳'.match(/[𝒳-𝒴]/)); // Error: Invalid regular expression
console.log('𝒳'.match(/[𝒳-𝒴]/u)); // раотает



warn("======== Квантификаторы +, *, ? и {n} ========");
/*
* Количество {n}
 Самый простой квантификатор — это число в фигурных скобках: {n}.
Он добавляется к символу (или символьному классу, или набору [...] и т.д.) и указывает, сколько их нам нужно.

* Точное количество: {5}
Шаблон \d{5} обозначает ровно 5 цифр, он эквивалентен \d\d\d\d\d.
*/
console.log("Мне 12345 лет".match(/\d{5}/)); //  "12345"
//  Добавляя \b, исключаются числа длиннее: \b\d{5}\b.

//* Диапазон: {3,5}, от 3 до 5
console.log("Мне не 12, а 1234 года".match(/\d{3,5}/)); // ["1234", ... }
// Верхнюю границу можно не указывать. Тогда шаблон \d{3,} найдёт последовательность чисел длиной 3 и более цифр:
console.log("Мне не 12, а 345678 лет".match(/\d{3,}/)); // ["345678", ... }

/*
* Короткие обозначения
Для самых востребованных квантификаторов есть сокращённые формы записи:
 · + - Означает «один или более». То же самое, что и {1,}.
  Например, \d+ находит числа (из одной или более цифр):
*/
let phone = "+7(903)-123-45-67";
console.log(phone.match(/\d+/g)); // ['7', '903', '123', '45', '67']
/*
 · ? - Означает «ноль или один». То же самое, что и {0,1}.
  Например, шаблон ou?r найдёт o после которого, возможно, следует u, а затем r. Поэтому шаблон colou?r найдёт два варианта: color и colour:
*/
let strFour = "Следует писать color или colour?";
console.log(strFour.match(/colou?r/g)); // ['color', 'colour']
/*
 · * - Означает «ноль или более». То же самое, что и {0,}. То есть символ может повторяться много раз или вообще отсутствовать.
  Например, шаблон \d0* находит цифру и все нули за ней (их может быть много или ни одного):
*/
console.log("100 10 1".match(/\d0*/g)); // ['100', '10', '1']
// Сравнение с + (один или более):
console.log("100 10 1".match(/\d0+/g)); // ['100', '10']


//! Ещё примеры
//* Регулярное выражение для десятичных дробей (чисел с плавающей точкой): \d+\.\d+
console.log("0 1 12.345 7890".match(/\d+\.\d+/g)); // ['12.345']

//* Регулярное выражение для «открывающего HTML-тега без атрибутов», например, <span> или <p>.
// Простое: /<[a-z]+>/i
console.log("<body> ... </body>".match(/<[a-z]+>/gi)); // ['<body>']
// Это регулярное выражение ищет символ '<', за которым идут одна или более букв латинского алфавита, а затем '>'.

// Улучшенное: /<[a-z][a-z0-9]*>/i
console.log("<h1>Привет!</h1>".match(/<[a-z][a-z0-9]*>/gi)); // ['<h1>']
// В соответствие со стандартом, в названии HTML-тега цифра может быть на любой позиции, кроме первой, например <h1>.

//* Регулярное выражение для «открывающего или закрывающего HTML-тега без атрибутов»: /<\/?[a-z][a-z0-9]*>/i
console.log("<h1>Привет!</h1>".match(/<\/?[a-z][a-z0-9]*>/gi)); // ['<h1>', '</h1>']
// В начало предыдущего шаблона добавлен необязательный слеш /?. Он заэкранирован, чтобы JavaScript не принял его за конец шаблона.



warn("======== Жадные и ленивые квантификаторы ========");
/*
* Жадный поиск
 Чтобы найти совпадение, движок регулярных выражений работает по следующему алгоритму:
Для каждой позиции в строке для поиска:
 · Попробовать найти совпадение с шаблоном на этой позиции.
 · Если нет совпадения, переход к следующей позиции.

 Например, есть текст, в котором нужно заменить все кавычки "..." на «ёлочки» «...».
Первое, что нам нужно – это найти строки с кавычками.
*/
let regGreedy = /".+"/g;
let strGreedy = 'a "witch" and her "broom" is one';
console.log(strGreedy.match(regGreedy)); // "witch" and her "broom" - это не то что требовалось..
/*
! В жадном режиме (по умолчанию) квантификатор повторяется столько раз, сколько это возможно.
 Движок регулярного выражения пытается получить максимальное количество символов, соответствующих .+,
а затем сокращает это количество символ за символом, если остаток шаблона не совпадает.
*/

/*
* Ленивый режим
 Он означает: «повторять квантификатор наименьшее количество раз».
Можно включить его, вставив знак вопроса '?' после квантификатора, то есть будет *? или +? или даже ?? для '?'.
 Обычно знак вопроса ? сам по себе является квантификатором (ноль или один), но, если он добавлен после другого квантификатора
(или даже после самого себя), он получает другое значение – он меняет режим совпадения с жадного на ленивый.
*/
let regLazy = /".+?"/g;
let strLazy = 'a "witch" and her "broom" is one';
console.log(strLazy.match(regLazy)); // witch, broom
/*
* Ленивый режим включается только для квантификаторов с ?.
 Остальные квантификаторы остаются жадными.
*/
console.log("123 456".match(/\d+ \d+?/)); // 123 4
/*
 1) Шаблон \d+ пытается найти столько цифр, сколько возможно (жадный режим), так что он находит 123 и останавливается,
  потому что следующим символом будет пробел ' '.
 2) Дальше в шаблоне пробел и в строке тоже, так что есть совпадение.
 3) Затем идёт \d+?. Квантификатор находится в ленивом режиме, так что он находит одну цифру 4 и проверяет,
  есть ли совпадение для оставшегося шаблона с этого места.
  · …Но в шаблоне \d+? больше ничего нет.
  · Ленивый режим ничего не повторяет без необходимости. Шаблон закончился, заканчивается и поиск. Мы получаем 123 4.
*/

/*
* Альтернативный подход
 С регулярными выражениями часто есть несколько путей добиться одного и того же результата.
В случае с ковычками их можно найти без использования ленивого режима с помощью регулярного выражения "[^"]+":
*/
let regAlt = /"[^"]+"/g;
let strAlt = 'a "witch" and her "broom" is one';
console.log(strAlt.match(regAlt)); // witch, broom
/*
 Регулярное выражение "[^"]+" получит нужный результат, потому что оно ищет кавычку '"',
за которой следует один или несколько символов «не-кавычек» [^"], а затем – закрывающая кавычка.
*/
/*
* Поиск в тексте ссылки с определённым классом
*/
let str1 = '...<a href="link1" class="wrong">... <p style="" class="doc">...';
let str2 = '...<a href="link1" class="doc">... <a href="link2" class="doc">...';
let regLink = /<a href="[^"]*" class="doc">/g;

console.log(str1.match(regLink)); // null - совпадений нет, всё правильно
console.log(str2.match(regLink)); // <a href="link1" class="doc">, <a href="link2" class="doc">



warn("======== Скобочные группы () ========");
/*
* Часть шаблона можно заключить в скобки (...). Это называется «скобочная группа».
 У такого выделения есть два эффекта:
 · Позволяет поместить часть совпадения в отдельный массив.
 · Если установить квантификатор после скобок, то он будет применяться ко всему содержимому скобки, а не к одному символу.

* Пример: gogogo
 Без скобок шаблон go+ означает символ g и идущий после него символ o, который повторяется один или более раз. Например, goooo или gooooooooo.
Скобки группируют символы вместе. Так что (go)+ означает go, gogo, gogogo и т.п.
*/
console.log('Gogogo now!'.match(/(go)+/i)); // ['Gogogo', 'go', ...]
/*
* Пример: домен
 Регулярное выражение, которое соответствует домену сайта.
 · mail.com
 · users.mail.com
 · smith.users.mail.com
 Как видно, домен состоит из повторяющихся слов, причём после каждого, кроме последнего, стоит точка.
На языке регулярных выражений (\w+\.)+\w+:
*/
let regDomen = /(\w+\.)+\w+/g;
console.log("site.com my.site.com".match(regDomen)); // site.com,my.site.com
/*
 Поиск работает, но такому шаблону не соответствует домен с дефисом, например, my-site.com, так как дефис не входит в класс \w.
Можно исправить это, заменим \w на [\w-] везде, кроме как в конце: ([\w-]+\.)+\w+.

* Пример: email
 Предыдущий пример можно расширить, создав регулярное выражение для поиска email.
Формат email: имя@домен. В качестве имени может быть любое слово, разрешены дефисы и точки. На языке регулярных выражений это [-.\w]+.
*/
let regMail = /[-.\w]+@([\w-]+\.)+[\w-]+/g;
console.log("my@mail.com @ his@site.com.uk".match(regMail)); // my@mail.com, his@site.com.uk

/*
* Содержимое скобок в match
 Скобочные группы нумеруются слева направо.
Метод str.match(regexp), если у регулярного выражения regexp нет флага g, ищет первое совпадение и возвращает его в виде массива:
 · На позиции 0 будет всё совпадение целиком.
 · На позиции 1 – содержимое первой скобочной группы.
 · На позиции 2 – содержимое второй скобочной группы.
 · …и так далее…
 Например, нужно найти HTML теги <.*?> и обработать их. Было бы удобно иметь содержимое тега (то, что внутри уголков) в отдельной переменной.
Получаем его заключив внутреннее содержимое в круглые скобки: <(.*?)>.
*/
let strTag = '<h1>Hello, world!</h1>';
let tag = strTag.match(/<(.*?)>/);
console.log(tag[0]); // <h1>
console.log(tag[1]); // h1
/*
* Вложенные группы
 Скобки могут быть и вложенными.
Например, при поиске тега в <span class="my"> нас может интересовать:
 · Содержимое тега целиком: span class="my".
 · Название тега: span.
 · Атрибуты тега: class="my".
 Заключим их в скобки в шаблоне: <(([a-z]+)\s*([^>]*))>.
*/
let strGroup = '<span class="my">';
let regGroup = /<(([a-z]+)\s*([^>]*))>/;
let resGroup = strGroup.match(regGroup);
console.log(resGroup[0]); // <span class="my"> - По нулевому индексу в result всегда идёт полное совпадение
console.log(resGroup[1]); // span class="my" - Затем следуют группы, нумеруемые слева направо, по открывающим скобкам
console.log(resGroup[2]); // span - Затем идёт группа, образованная второй открывающей скобкой ([a-z]+) – имя тега
console.log(resGroup[3]); // class="my" - И в завершении будет остальное содержимое тега: ([^>]*)
/*
* Необязательные группы
 Даже если скобочная группа необязательна (например, стоит квантификатор (...)?), соответствующий элемент массива result существует и равен undefined.
Регулярное выражение a(z)?(c)?. Оно ищет букву "a", за которой идёт необязательная буква "z", за которой, в свою очередь, идёт необязательная буква "c".
*/
let matchA = 'a'.match(/a(z)?(c)?/);
console.log(matchA.length); // 3
console.log(matchA[0]); // a (всё совпадение)
console.log(matchA[1]); // undefined
console.log(matchA[2]); // undefined

// А теперь более сложная ситуация для строки ac:
let matchAc = 'ac'.match(/a(z)?(c)?/)
console.log(matchAc.length); // 3
console.log(matchAc[0]); // ac (всё совпадение)
console.log(matchAc[1]); // undefined, потому что для (z)? ничего нет
console.log(matchAc[2]); // c

/*
* Поиск всех совпадений с группами: matchAll
! Может потребоваться полифил, например https://github.com/ljharb/String.prototype.matchAll.
 При поиске всех совпадений (флаг g) метод match не возвращает скобочные группы.
*/
let strTags = '<h1> <h2>';
let tags = strTags.match(/<(.*?)>/g);
console.log(tags); // <h1>,<h2>
/*
 Результат – массив совпадений, но без деталей о каждом. Но на практике скобочные группы тоже часто нужны.
Для того, чтобы их получать, мы можем использовать метод str.matchAll(regexp).
 Отличия от str.match(regexp)Ж
 · Он возвращает не массив, а перебираемый объект.
 · При поиске с флагом g, он возвращает каждое совпадение в виде массива со скобочными группами.
 · Если совпадений нет, он возвращает не null, а просто пустой перебираемый объект.
*/
let results = '<h1> <h2>'.matchAll(/<(.*?)>/gi);
// results - не массив, а перебираемый объект
console.log(results); // [object RegExp String Iterator]
console.log(results[0]); // undefined (*)

results = Array.from(results); // превращаем в массив
console.log(results[0]); // <h1>,h1 (первый тег)
console.log(results[1]); // <h2>,h2 (второй тег)

// Перебираемый объект перебирается через for of:
for (let res of results) console.log(res); // первый вывод: <h1>,h1 ; второй: <h2>,h2

// …Или используем деструктуризацию:
let [tag1, tag2] = '<h1> <h2>'.matchAll(/<(.*?)>/gi);
/*
 Каждое совпадение, возвращаемое matchAll, имеет тот же вид, что и при match без флага g: это
массив с дополнительными свойствами index (позиция совпадения) и input (исходный текст):
*/
console.log(tag1[0]); // <h1>
console.log(tag1[1]); // h1
console.log(tag1.index); // 0
console.log(tag1.input); // <h1> <h2>

/*
* Именованные группы
 Запоминать группы по номерам не очень удобно. Для простых шаблонов это допустимо, но в сложных регулярных выражениях считать скобки затруднительно.
Гораздо лучше – давать скобкам имена. Это делается добавлением ?<name> непосредственно после открытия скобки.
*/
let dateRegexp = /(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})/;
let strDate = "2019-04-30";

let groups = strDate.match(dateRegexp).groups; // группы теперь располагаются в свойстве groups результата match.
console.log(groups.year); // 2019
console.log(groups.month); // 04
console.log(groups.day); // 30
/*
 Чтобы найти не только первую дату, используем флаг g.
Также понадобится matchAll, чтобы получить скобочные группы:
*/
let datesRegexp = /(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})/g;
let strDates = "2019-10-30 2020-01-01";
let datesResults = strDates.matchAll(datesRegexp);

for (let result of datesResults) {
	let { year, month, day } = result.groups;

	console.log(`${day}.${month}.${year}`);
	// первый вывод: 30.10.2019
	// второй: 01.01.2020
}

/*
* Скобочные группы при замене
Метод str.replace(regexp, replacement), осуществляющий замену совпадений с regexp в строке str, позволяет использовать в строке замены содержимое скобок.
Это делается при помощи обозначений вида $n, где n – номер скобочной группы.
*/
let johnBull = "John Bull";
let regJohn = /(\w+) (\w+)/;
console.log(johnBull.replace(regJohn, '$2, $1')); // Bull, John

// Для именованных скобок ссылка будет выглядеть как $<имя>. Заменим даты в формате «год-месяц-день» на «день.месяц.год»:
let regNamedDates = /(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})/g;
let strDatesTwo = "2019-10-30, 2020-01-01";
console.log(strDatesTwo.replace(regNamedDates, '$<day>.$<month>.$<year>')); // 30.10.2019, 01.01.2020

/*
* Исключение из запоминания через ?:
 Бывает так, что скобки нужны, чтобы квантификатор правильно применился, но мы не хотим, чтобы их содержимое было выделено в результате.
Скобочную группу можно исключить из запоминаемых и нумеруемых, добавив в её начало ?:.
*/
let john = "Gogogo John!";
let regGoJohn = /(?:go)+ (\w+)/i; //. ?: исключает go из запоминания
let resGoJohn = john.match(regGoJohn);
console.log(resGoJohn[0]); // Gogogo John (полное совпадение)
console.log(resGoJohn[1]); // John
console.log(resGoJohn.length); // 2 (больше в массиве элементов нет)



warn("=== Обратные ссылки в шаблоне: \N и \k<имя> ===");
/*
 Доступ к содержимому скобочных групп (...) есть не только в результате поиска и при замене, но и в самом шаблоне.

* Обратная ссылка по номеру: \N
 К группе можно обратиться в шаблоне, используя \N, где N – это номер группы.
К примеру необходимо найти строки в кавычках: либо одинарных '...', либо двойных "..." – оба варианта должны подходить.
 Для того, чтобы шаблон искал закрывающую кавычку такую же, как и открывающую, обернём открывающие кавычки в скобочную группу
и используем обратную ссылку на неё: (['"])(.*?)\1.
*/
let strNTwo = `He said: "She's the one!".`;
let regNTwo = /(['"])(.*?)\1/g;
console.log(strNTwo.match(regNTwo)); // "She's the one!"
/*
 Движок регулярных выражений находит первую кавычку из шаблона (['"]) и запоминает её содержимое. Это первая скобочная группа.
Далее в шаблоне \1 означает «найти то же самое, что в первой скобочной группе», а именно – аналогичную кавычку в нашем случае.
Аналогично, \2 означает содержимое второй скобочной группы, \3 – третьей, и так далее.


* Обратная ссылка по имени: \k<имя>
 Для обращения к именованной группе можно использовать синтаксис \k<имя>.
В примере ниже кавычки обозначены ?<quote>, так что обращение будет \k<quote>:
*/
let strLinkNamed = `He said: "She's the one!".`;
let regLinkNamed = /(?<quote>['"])(.*?)\k<quote>/g;
console.log(strLinkNamed.match(regLinkNamed)); // "She's the one!"



warn("======== Альтернация (или) | ========");
/*
* Альтернация – термин в регулярных выражениях, которому в русском языке соответствует слово «ИЛИ».
 В регулярных выражениях она обозначается символом вертикальной черты |.
Например, нам нужно найти языки программирования: HTML, PHP, Java и JavaScript.
*/
let regAlternation = /html|css|java(script)?/gi;
let strAlternation = "Сначала появился язык Java, затем HTML, потом JavaScript";
console.log(strAlternation.match(regAlternation)); // Java,HTML,JavaScript
/*
 К скобки тоже позволяют выбирать между несколькими символами, например gr[ae]y найдёт gray, либо grey.
Альтернация мощнее, она работает с любыми выражениями. Регулярное выражение A|B|C обозначает поиск одного из выражений: A, B или C.
 · gr(a|e)y означает точно то же, что и gr[ae]y.
 · gra|ey означает gra или ey.

 Чтобы применить альтернацию только к части шаблона, можно заключить её в скобки:
 · Люблю HTML|CSS найдёт Люблю HTML или CSS.
 · Люблю (HTML|CSS) найдёт Люблю HTML или Люблю CSS.

* Пример: шаблон для времени (улучшенная версия задачи выше)
Шаблон \d\d:\d\d недостаточно точный, он принимает и 25:99 за время. Поправки:
 · Если первая цифра 0 или 1, тогда следующая цифра может быть любой: [01]\d.
 · Или если первая цифра 2, тогда следующая должна быть от 0 до 3: 2[0-3].
 · (другой первой цифры быть не может): [01]\d|2[0-3].
 · Минуты должны быть от 00 до 59: [0-5]\d
! Соединив часы и минуты в одно выражение, получится: [01]\d|2[0-3]:[0-5]\d. Но это не правильно!
После такого соединения альтернация | оказалась между [01]\d и 2[0-3]:[0-5]\d. То есть, минуты добавились ко второму варианту альтернации.
 Такой шаблон будет искать [01]\d или 2[0-3]:[0-5]\d. Необходимо обернуть «часы» в скобки:
*/
let regNewTime = /([01]\d|2[0-3]):[0-5]\d/g;
console.log("00:00 10:10 23:59 25:99 1:2".match(regNewTime)); // ['00:00', '10:10', '23:59']


warn("=== Опережающие и ретроспективные проверки ===");
/*
 В некоторых случаях нам нужно найти соответствия шаблону, но только те, за которыми или перед которыми следует другой шаблон.
Для этого в регулярных выражениях есть специальный синтаксис: опережающая (lookahead) и ретроспективная (lookbehind) проверка.

* Опережающая проверка
 Синтаксис опережающей проверки: X(?=Y). Он означает: найди X при условии, что за ним следует Y.
Поиск стоимости из строки: 1 индейка стоит 30€. 
*/
let strTurkey = "1 индейка стоит 30€";
console.log(strTurkey.match(/\d+(?=€)/)); // 30, число 1 проигнорировано, так как за ним НЕ следует €
/*
 Проверка – это именно проверка, содержимое скобок (?=...) не включается в результат 30.
Возможны и более сложные проверки, например X(?=Y)(?=Z) означает:
 · Найти X.
 · Проверить, идёт ли Y сразу после X (если нет – не подходит).
 · Проверить, идёт ли Z сразу после X (если нет – не подходит).
 · Если обе проверки прошли – совпадение найдено.
 Такое возможно только при условии, что шаблоны Y и Z не являются взаимно исключающими.
Например, \d+(?=\s)(?=.*30) ищет \d+ при условии, что за ним идёт пробел, и где-то впереди есть 30:
*/
let strTurkeyOne = "1 индейка стоит 30€";
console.log(strTurkeyOne.match(/\d+(?=\s)(?=.*30)/)); // 1

/*
* Негативная опережающая проверка
 Допустим, нам нужно узнать из этой же строки количество индеек, то есть число \d+, за которым НЕ следует знак €.
Для этой задачи мы можем применить негативную опережающую проверку.
 Синтаксис: X(?!Y) - он означает: найди такой X, за которым НЕ следует Y.
*/
let strTurkeyNeg = "2 индейки стоят 60€";
console.log(strTurkeyNeg.match(/\d+(?!€)/)); // 2 (в этот раз проигнорирована цена)

/*
* Ретроспективная проверка
 Опережающие проверки позволяют задавать условия на то, что «идёт после».
Ретроспективная проверка находит соответствие шаблону, только если перед ним есть что-то заранее определённое.
 Синтаксис:
 · Позитивная ретроспективная проверка: (?<=Y)X, ищет совпадение с X при условии, что перед ним ЕСТЬ Y.
 · Негативная ретроспективная проверка: (?<!Y)X, ищет совпадение с X при условии, что перед ним НЕТ Y.

 Чтобы протестировать ретроспективную проверку, поменяем валюту на доллары США. Знак доллара обычно ставится перед суммой денег,
поэтому для того чтобы найти $30, используем (?<=\$)\d+ – число, перед которым идёт $:
*/
let strTurkeyRetro = "1 индейка стоит $30";
// знак доллара экранируем \$, так как это специальный символ
console.log(strTurkeyRetro.match(/(?<=\$)\d+/)); // 30, одинокое число игнорируется

// Если необходимо найти количество индеек – число, перед которым не идёт $, используется негативная ретроспективная проверка (?<!\$)\d+:
let strTurkeyNegRetro = "2 индейки стоят $60";
console.log(strTurkeyNegRetro.match(/(?<!\$)\d+/)); // 2 (проигнорировалась цена)

/*
* Скобочные группы
 То что находится внутри скобок, задающих опережающую и ретроспективную проверку, не включается в результат совпадения.
Но в некоторых ситуациях неоходимо захватить и то, что в проверке. Для этого нужно обернуть это в дополнительные скобки.
*/
let strTurkeyNegGroup = "1 индейка стоит 30€";
console.log(strTurkeyNegGroup.match(/\d+(?=(€|kr))/)); // 30, €

// То же самое можно применить к ретроспективной проверке:
let strTurkeyNegRetroGroup = "2 индейка стоит $60";
console.log(strTurkeyNegRetroGroup.match(/(?<=(\$|£))\d+/)); // 60, $

/*
! Виды проверок:

Шаблон	       \  Тип	                                     \  Совпадение
________________\____________________________________________\______________________________________________________________
X(?=Y)	       \  Позитивная опережающая	                   \  X, если за ним следует Y
----------------\--------------------------------------------\--------------------------------------------------------------
X(?!Y)	       \  Негативная опережающая	                   \  X, если за ним НЕ следует Y
----------------\--------------------------------------------\--------------------------------------------------------------
(?<=Y)X	       \  Позитивная ретроспективная	             \  X, если следует за Y
----------------\--------------------------------------------\--------------------------------------------------------------
(?<!Y)X	       \  Негативная ретроспективная	             \  X, если НЕ следует за Y
----------------\--------------------------------------------\--------------------------------------------------------------
*/


warn("======== Катастрофический возврат ========");
// Некоторые регулярные выражения, простые с виду, могут выполняться оооочень долго, и даже «подвешивать» интерпретатор JavaScript.
let regErr = /^(\w+\s?)*$/;
let strErr = "An input string that takes a long time or even makes this regexp to hang!";
//! console.log(regErr.test(strErr));  этот поиск будет выполняться очень, очень долго
/*
 Человеку очевидно, что совпадения быть не может, так как эта строка заканчивается на восклицательный знак !, а по регулярному выражению
в конце должен быть символ \w или пробел \s. Но движок этого не знает.
 Он перебирает все комбинации того, как регулярное выражение (\w+\s?)* может «захватить» каждое слово, включая варианты как с пробелами (\w+\s)*,
так и без (\w+)* (пробелы \s? ведь не обязательны). Этих вариантов очень много, отсюда и сверхдолгое время выполнения.

* Как исправить? Есть два основных подхода.
 Первый – уменьшить количество возможных комбинаций.
Перепишем регулярное выражение так: ^(\w+\s)*\w* – то есть, будем искать любое количество слов с пробелом (\w+\s)*,
после которых идёт (но не обязательно) обычное слово \w*.
 Это регулярное выражение эквивалентно предыдущему (ищет то же самое), и на этот раз всё работает:
*/
let regSol = /^(\w+\s)*\w*$/;
console.log(regSol.test(strErr)); // false
/*
 Теперь звёздочка * стоит после \w+\s вместо \w+\s?. Стало невозможно разбить одно слово на несколько разных \w+.
Исчезли и потери времени на перебор таких комбинаций. С переписанным шаблоном (\w+\s)*, такое невозможно: может быть \w+\s или \w+\s\w+\s, но не \w+\w+.
Так что общее количество комбинаций сильно уменьшается.

* Запрет возврата
 Альтернативный подход заключается в том, чтобы запретить возврат для квантификатора. В данном случае нужно исключить возврат для \w+.
То есть, для \w+ нужно искать только одно слово целиком, максимально возможной длины.

 В современных регулярных выражениях для решения этой проблемы придумали захватывающие (possessive) квантификаторы, которые такие же как жадные,
но не делают возврат. Также есть «атомарные скобочные группы» – средство, запрещающее возврат внутри скобок.
! К сожалению, в JavaScript они не поддерживаются, но есть другое средство.

* Опережающая проверка
 Шаблон, захватывающий максимальное количество повторений \w без возврата, выглядит так: (?=(\w+))\1.
 · Опережающая проверка ?= ищет максимальное количество \w+, доступных с текущей позиции.
 · Содержимое скобок вокруг ?=... не запоминается движком, поэтому оборачиваем \w+ внутри в дополнительные скобки,запрет
  чтобы движок регулярных выражений запомнил их содержимое.
 · …И чтобы далее в шаблоне на него сослаться обратной ссылкой \1.
 Такой шаблон в слове JavaScript не может захватить только Java, и оставить Script для совпадения с остатком шаблона.
*/
console.log("JavaScript".match(/\w+Script/)); // JavaScript
console.log("JavaScript".match(/(?=(\w+))\1Script/)); // null

// Исходный пример, используя опережающую проверку для запрета возврата:
let regSolNoReturn = /^((?=(\w+))\2\s?)*$/;
console.log(strErr.match(regSolNoReturn)); // null, работает и быстро
// Здесь внутри скобок стоит \2 вместо \1, так как есть ещё внешние скобки. Чтобы избежать путаницы с номерами скобок, можно дать скобкам имя.
let regSolNoReturnNamed = /^((?=(?<word>\w+))\k<word>\s?)*$/;
console.log(regSolNoReturnNamed.test("A good string")); // true
console.log(regSolNoReturnNamed.test(strErr)); // false



warn("======== Поиск на заданной позиции, флаг 'y' ========");
/*
 Одна из часто встречающихся задач регулярных выражений – лексический разбор: мы имеем текст, например, на каком-то языке программирования
и получаем его структурные элементы.
 Например, у нас есть строка кода let varName = "value", и нам надо прочитать из неё имя переменной, которое начинается с позиции 4.
Вызов str.match(/\w+/) найдёт только первое слово в строке или все слова (с флагом g), а нам нужно одно слово именно на позиции 4.
* Для поиска, начиная с нужной позиции, можно использовать метод regexp.exec(str).
 Если у регулярного выражения regexp нет флагов g или y, то этот метод ищет первое совпадение в строке str, точно так же, как str.match(regexp).
Если флаг g есть, то он осуществляет поиск в строке str, начиная с позиции, заданной свойством regexp.lastIndex.
И, когда находит, обновляет regexp.lastIndex на позицию после совпадения.
 При создании регулярного выражения его свойство lastIndex равно 0.
Так что повторные вызовы regexp.exec возвращают совпадения по очереди, одно за другим.
*/
let strPosition = 'let varName';
let regPos = /\w+/g; //! без флага g свойство lastIndex игнорируется
console.log(regPos.lastIndex); // 0 - при создании lastIndex=0

let word1 = regPos.exec(strPosition);
console.log(word1[0]); // let (первое слово)
console.log(regPos.lastIndex); // 3 - позиция за первым совпадением

let word2 = regPos.exec(strPosition);
console.log(word2[0]); // varName - второе слово
console.log(regPos.lastIndex); // 11 - позиция за вторым совпадением

let word3 = regPos.exec(strPosition);
console.log(word3); // null (больше совпадений нет)
console.log(regPos.lastIndex); // 0 (сбрасывается по окончании поиска)

//* Каждое совпадение возвращается в виде массива, со всеми скобочными группами и дополнительными свойствами. Можно перебрать все совпадения в цикле:
let res;
while (res = regPos.exec(strPosition)) {
	console.log(`Найдено ${res[0]} на позиции ${res.index}`);
	// Найдено let на позиции 0
	// Найдено varName на позиции 4
}
/*
 Таким образом, последовательные вызовы regexp.exec могут найти все совпадения, представляя собой альтернативу методам str.match/matchAll.
Но, в отличие от других методов, можно самостоятельно поставить lastIndex, начав тем самым поиск именно с нужной позиции.
*/
let strPositionTwo = 'let varName = "value"';
regPos.lastIndex = 4;

let wordOne = regPos.exec(strPositionTwo);
console.log(wordOne); // varName

//! Такой поиск лишь начинается с позиции lastIndex и идёт дальше. Если слова на позиции lastIndex нет, но оно есть позже, оно всё равно будет найдено:
regPos.lastIndex = 3;
let wordTwo = regPos.exec(strPositionTwo);
console.log(wordTwo[0]); // varName
console.log(wordTwo.index); // 4

//! Флаг y заставляет regexp.exec искать ровно на позиции lastIndex, ни до и ни после.
let regPosY = /\w+/y;
regPosY.lastIndex = 3;
console.log(regPosY.exec(strPositionTwo)); // null (на позиции 3 пробел, а не слово)

regPosY.lastIndex = 4;
console.log(regPosY.exec(strPositionTwo)); // varName - слово на позиции 4
/*
  Допустим, в большом тексте, нет ни одного совпадения. В таком случае регулярное выражение с флагом g будет идти до самого конца текста,
 и это займёт гораздо больше времени, чем поиск с флагом y. Использование флага y – ключ к хорошей производительности.
*/


warn("======== Методы RegExp и String ========");
/*
* str.match(regexp)
 Метод str.match(regexp) ищет совпадения с regexp в строке str.
У него есть три режима работы:
 1) Если у регулярного выражения нет флага g, то он возвращает первое совпадение в виде массива со скобочными группами
и свойствами index (позиция совпадения), input (строка поиска, равна str):
*/
let str = "I love JavaScript";
let resMatch = str.match(/Java(Script)/);

console.log(resMatch[0]); // JavaScript (всё совпадение)
console.log(resMatch[1]); // Script (первые скобки)
console.log(resMatch.length); // 2
// Дополнительная информация:
console.log(resMatch.index); // 7 (позиция совпадения)
console.log(resMatch.input); // I love JavaScript (исходная строка)

// 2) Если у регулярного выражения есть флаг g, то он возвращает массив всех совпадений, без скобочных групп и других деталей.
let resMatchG = str.match(/Java(Script)/g);
console.log(resMatchG[0]); // JavaScript
console.log(resMatchG.length); // 1

// 3) Если совпадений нет, то, вне зависимости от наличия флага g, возвращается null. 
let resMatchNull = str.match(/HTML/);
console.log(resMatchNull); // JavaScript
// console.log(resMatchNull.length); // Ошибка: у null нет свойства length (решается || [])

/*
* str.matchAll(regexp)
 Ипользуется, в первую очередь, для поиска всех совпадений вместе со скобочными группами.
У него 3 отличия от match:
 · Он возвращает не массив, а перебираемый объект с результатами, обычный массив можно сделать при помощи Array.from.
 · Каждое совпадение возвращается в виде массива со скобочными группами (как str.match без флага g).
 · Если совпадений нет, то возвращается не null, а пустой перебираемый объект.
*/
let strMatchAll = '<h1>Hello, world!</h1>';
let regMatchAll = /<(.*?)>/g;
let matchAll = strMatchAll.matchAll(regMatchAll);

console.log(matchAll); // [object RegExp String Iterator], не массив, а перебираемый объект
matchAll = Array.from(matchAll); // теперь массив

let firstMatch = matchAll[0];
console.log(firstMatch[0]);  // <h1>
console.log(firstMatch[1]);  // h1
console.log(firstMatch.index);  // 0
console.log(firstMatch.input);  // <h1>Hello, world!</h1>

/*
* str.split(regexp|substr, limit)
Разбивает строку в массив по разделителю – регулярному выражению regexp или подстроке substr.
*/
console.log('12-34-56'.split('-')) // массив [12, 34, 56]);

// Аналогичным образом через регулярное выражение: 
console.log('12, 34, 56'.split(/,\s*/)) // массив [12, 34, 56]

/*
* str.search(regexp)
Метод str.search(regexp) возвращает позицию первого совпадения с regexp в строке str или -1, если совпадения нет.
*/
console.log("I love JavaScript".search(/Java.+/)); // 7
//! str.search умеет возвращать только позицию первого совпадения.
// Если нужны позиции других совпадений, то найти их можно при помощи str.matchAll(regexp).

/*
* str.replace(str|regexp, str|func)
 Это универсальный метод поиска-и-замены. К примеру заменить тире двоеточием:
*/
console.log('12-34-56'.replace("-", ":")); // 12:34-56
//! Когда первый аргумент replace является строкой, он заменяет только первое совпадение.
//! Чтобы найти все дефисы, нужно использовать не строку "-", а регулярное выражение /-/g с обязательным флагом g:
console.log('12-34-56'.replace(/-/g, ":"));  // 12:34:56
/*
* Второй аргумент – строка замены. Мы можем использовать специальные символы в нем:

Спецсимволы	      \     Действие в строке замены
__________________\________________________________________________________________________________
$$	               \     вставляет "$"
------------------\--------------------------------------------------------------------------------
$&	               \     вставляет всё найденное совпадение
------------------\--------------------------------------------------------------------------------
$`	               \     вставляет часть строки до совпадения
------------------\--------------------------------------------------------------------------------
$'	               \     вставляет часть строки после совпадения
------------------\--------------------------------------------------------------------------------
$n	               \     если n это 1-2 значное число, то вставляет содержимое n-й скобки
------------------\--------------------------------------------------------------------------------
$<имя>	         \     вставляет содержимое скобки с указанным именем
------------------\--------------------------------------------------------------------------------
*/
let smith = "John Smith"; // поменять местами имя и фамилию
console.log(smith.replace(/(\w+) (\w+)/i, '$2, $1')); // Smith, John
/*
! Для ситуаций, которые требуют «умных» замен, вторым аргументом может быть функция.
 Она будет вызываться для каждого совпадения, и её результат будет вставлен в качестве замены.
* Функция вызывается с аргументами func(match, p1, p2, ..., pn, offset, input, groups):
 · match – найденное совпадение,
 · p1, p2, ..., pn – содержимое скобок (см. главу Скобочные группы).
 · offset – позиция, на которой найдено совпадение,
 · input – исходная строка,
 · groups – объект с содержимым именованных скобок (см. главу Скобочные группы).
 Если скобок в регулярном выражении нет, то будет только 3 аргумента: func(match, offset, input).
*/
let strHtmlCss = "html and css";
let resultHtmlCss = strHtmlCss.replace(/html|css/gi, str => str.toUpperCase());
console.log(resultHtmlCss); // HTML and CSS

// Замена каждого совпадения на его позицию в строке:
console.log("Хо-Хо-хо".replace(/хо/gi, (match, offset) => offset)); // 0-3-6
/*
 В примере ниже две скобки, поэтому функция замены вызывается с 5-ю аргументами: первый – всё совпадение, затем два аргумента содержимое скобок,
затем индекс совпадения и исходная строка:
*/
console.log(smith.replace(/(\w+) (\w+)/, (match, name, surname) => `${surname}, ${name}`)); // Smith, John

// Если в регулярном выражении много скобочных групп, то бывает удобно использовать остаточные аргументы для обращения к ним:
console.log(smith.replace(/(\w+) (\w+)/, (...match) => `${match[2]}, ${match[1]}`)); // Smith, John

// При использовании именованных групп объект groups с ними всегда идёт последним, так что можно получить его так:
let resultSmith = smith.replace(/(?<name>\w+) (?<surname>\w+)/, (...match) => {
	let groups = match.pop();
	return `${groups.surname}, ${groups.name}`;
});
console.log(resultSmith); // Smith, John

/*
* regexp.exec(str)
 Метод regexp.exec(str) ищет совпадение с regexp в строке str. В отличие от предыдущих методов, вызывается на регулярном выражении, а не на строке.
* Если нет g, то regexp.exec(str) возвращает первое совпадение в точности как str.match(regexp). Но если есть g, то:
 · Вызов regexp.exec(str) возвращает первое совпадение и запоминает позицию после него в свойстве regexp.lastIndex.
 · Следующий такой вызов начинает поиск с позиции regexp.lastIndex, возвращает следующее совпадение и запоминает позицию после него в regexp.lastIndex.
 · …И так далее.
 · Если совпадений больше нет, то regexp.exec возвращает null, а для regexp.lastIndex устанавливается значение 0.
*/
let strJS = 'Больше о JavaScript на https://javascript.info';
let regexpJS = /javascript/ig;
let resultJS;

while (resultJS = regexpJS.exec(strJS)) {
	console.log(`Найдено ${resultJS[0]} на позиции ${resultJS.index}`);
	// Найдено JavaScript на позиции 9
	// Найдено javascript на позиции 31
}
//! Можно использовать regexp.exec для поиска совпадения, начиная с нужной позиции, если вручную поставим lastIndex.
let hello = 'Hello, world!';
let regexpHello = /\w+/g; // без флага g свойство lastIndex игнорируется
regexpHello.lastIndex = 5; // ищем с 5-й позиции (т.е с запятой и далее)
console.log(regexpHello.exec(hello)); // world

//! Если у регулярного выражения стоит флаг y, то поиск будет вестись не начиная с позиции regexp.lastIndex, а ТОЛЬКО на этой позиции.
let helloTwo = 'Hello, world!';
let regexpHelloTwo = /\w+/y;
regexpHelloTwo.lastIndex = 5; // ищем ровно на 5-й позиции
console.log(regexpHelloTwo.exec(helloTwo)); // null

/*
* regexp.test(str)
Метод regexp.test(str) ищет совпадение и возвращает true/false, в зависимости от того, находит ли он его.
*/
console.log(/love/i.test("I love JavaScript")); // true
console.log("I love JavaScript".search(/love/i) != -1); // true - тоже самое

//! Если регулярное выражение имеет флаг g, то regexp.test ищет, начиная с regexp.lastIndex и обновляет это свойство, аналогично regexp.exec.
let regLove = /love/g;
regLove.lastIndex = 10; // начать поиск с 10-й позиции
console.log(regLove.test("I love JavaScript")); // false (совпадений нет)









// Задачка
function disemvowel(str) {
	return str.replace(/[aeiouy]/gims, '')
}

console.log(disemvowel("This website is for losers LOL!"), "Ths wbst s fr lsrs LL!")
console.log(disemvowel("No offense but,\nYour writing is among the worst I've ever read"), "N ffns bt,\nYr wrtng s mng th wrst 'v vr rd")
console.log(disemvowel("What are you, a communist?"), "Wht r y,  cmmnst?")

