let { warn } = console;


warn("======== Свойства и методы формы ========");
/*
* Навигация: формы и элементы
 Формы в документе входят в специальную коллекцию document.forms.
Это так называемая «именованная» коллекция: мы можем использовать для получения формы как её имя,
так и порядковый номер в документе.
*/
document.forms.my // форма с именем "my" (name="my")
document.forms[0] // первая форма в документе

// Когда мы уже получили форму, любой элемент доступен в именованной коллекции form.elements.
// получаем форму
let form = document.forms.my; // <form name="my"> element
// получаем элемент
let elem = form.elements.one; // <input name="one"> element
console.log(elem.value); // 1 (в дальнейшем будет поменяно)

/*
 Может быть несколько элементов с одним и тем же именем, это часто бывает с кнопками-переключателями radio.
В этом случае form.elements[name] является коллекцией.
*/
let radioForm = document.forms.radios;
let ages = radioForm.elements.age;
console.log(ages); // RadioNodeList(2) [input, input, value: '']
console.log(ages[0]); // <input type="radio" name="age" value="10">

/*
 Форма может содержать один или несколько элементов <fieldset> внутри себя. Они также поддерживают свойство elements,
в котором находятся элементы управления внутри них.
*/
console.log(fieldset_form.elements.login); // <input name="login" type="text">

let fieldset = fieldset_form.elements.userFields;
console.log(fieldset); // <fieldset name="userFields">...</fieldset>

/*
* Сокращённая форма записи: form.name
 Есть более короткая запись: мы можем получить доступ к элементу через form[index/name].
Другими словами, вместо form.elements.login мы можем написать form.login.
! Но есть небольшая проблема: если мы получаем элемент, а затем меняем его свойство name,
! то он всё ещё будет доступен под старым именем (также, как и под новым).
*/
console.log(logForm.elements.login === logForm.login); // true, ведь это одинаковые <input>
logForm.login.name = "username" // изменяем свойство name у элемента input

// form.elements обновили свои имена:
console.log(logForm.elements.login); // undefined
console.log(logForm.elements.username); // input....

// а в form мы можем использовать оба имени: новое и старое
console.log(logForm.username === logForm.login); // true

/*
* Обратная ссылка: element.form
 Для любого элемента форма доступна через element.form. Так что форма ссылается на все элементы,
а эти элементы ссылаются на форму.
*/
let login1 = textform.login1;
console.log(login1.form); // <form id="textform">...</form>


warn("======== Элементы формы ========");
/*
* input и textarea
 К их значению можно получить доступ через свойство input.value (строка)
или input.checked (булево значение) для чекбоксов.
*/
elem.value = 'Новое значение'; // значение поменялось с 1 на "новое"
form.tree.value = "Новый текст"; // в textarea появится текст
ages[0].checked = true; // первая радиокнопка теперь нажата
/*
! Использовать textarea.value вместо textarea.innerHTML
 Хоть элемент <textarea>...</textarea> и хранит своё значение как вложенный HTML, 
не следует использовать textarea.innerHTML для доступа к нему.
 Там хранится только тот HTML, который был изначально на странице, а не текущее значение.


* select и option
 Элемент <select> имеет 3 важных свойства:
 · select.options – коллекция из подэлементов <option>,
 · select.value – значение выбранного в данный момент <option>,
 · select.selectedIndex – номер выбранного <option>.

 Они дают три разных способа установить значение в <select>:
 · Найти соответствующий элемент <option> и установить в option.selected значение true.
 · Установить в select.value значение нужного <option>.
 · Установить в select.selectedIndex номер нужного <option>.
*/
// Все три строки делают одно и то же
fruits.options[2].selected = true;
fruits.selectedIndex = 2;
fruits.value = 'banana';
/*
 В отличие от большинства других элементов управления, <select> позволяет нам выбрать несколько вариантов одновременно,
если у него стоит атрибут multiple. Эту возможность используют редко, но в этом случае для работы со значениями
! необходимо использовать первый способ, то есть ставить или удалять свойство selected у подэлементов <option>.
*/
// Их коллекцию можно получить как select.options
console.log(music.options);

// получаем все выбранные значения из select с multiple
let selectedMusic = Array.from(music.options).filter(option => option.selected).map(option => option.value);
console.log(selectedMusic); // (2) ['blues', 'rock']

/*
* new Option
 Элемент <option> редко используется сам по себе.
option = new Option(text, value, defaultSelected, selected);
 · text – текст внутри <option>
 · value – значение
 · defaultSelected – если true, то ставится HTML-атрибут selected
 · selected – если true, то элемент <option> будет выбранным

 defaultSelected задаёт HTML-атрибут, его можно получить как option.getAttribute('selected')
 selected – выбрано значение или нет, именно его важно поставить правильно.
*/
let newOption = new Option("Текст", "value"); // создаст <option value="value">Текст</option>
// Тот же элемент, но выбранный:
let newOptionTwo = new Option("Текст", "value", true, true);
/*
 Cвойства элементов <option>:
 · option.selected - выбрана ли опция
 · option.index - номер опции среди других в списке <select>
 · option.value - значение опции
 · option.text - содержимое опции (то, что видит посетитель)
*/


warn("======== Фокусировка: focus/blur ========");
/*
 Элемент получает фокус, когда пользователь кликает по нему или использует клавишу Tab.
Также существует HTML-атрибут autofocus, который устанавливает фокус на элемент, когда страница загружается.
 Момент потери фокуса («blur») может быть важнее. Это момент, когда пользователь кликает куда-то ещё или нажимает Tab,
чтобы переключиться на следующее поле формы.

* События focus/blur
Используются для валидации(проверки) введённых данных.
 · Обработчик blur проверяет, введён ли email, и если нет – показывает ошибку.
 · Обработчик focus скрывает это сообщение об ошибке (в момент потери фокуса проверка повторится):
*/
input1.onblur = () => {
   if (!input1.value.includes('@')) {
      input1.classList.add('invalid');
      error.innerHTML = 'Пожалуйста, введите правильный email.';
   }
}
input1.onfocus = function () {
   if (this.classList.contains('invalid')) {
      this.classList.remove('invalid');
      error.innerHTML = '';
   }
}

/*
* Методы focus/blur
 Методы elem.focus() и elem.blur() устанавливают/снимают фокус.
Например, запретим посетителю переключаться с поля ввода, если введённое значение не прошло валидацию.
*/
input2.onblur = function () {
   if (!this.value.includes('@')) { // не email
      this.classList.add('error'); // показать ошибку
      this.focus(); // вернуть фокус назад
   } else {
      this.classList.remove('error');
   }
};
/*
!  Отметим, что мы не можем «отменить потерю фокуса», вызвав event.preventDefault() в обработчике onblur потому,
! то onblur срабатывает после потери фокуса элементом.


* Включаем фокусировку на любом элементе: tabindex
 Поддержка focus/blur гарантирована для элементов, с которыми посетитель может взаимодействовать: 
<button>, <input>, <select>, <a> и т.д.
С другой стороны, элементы форматирования <div>, <span>, <table> – по умолчанию не могут получить фокус.
 Это можно изменить HTML-атрибутом tabindex.

 Любой элемент поддерживает фокусировку, если имеет tabindex. Значение этого атрибута – порядковый номер элемента,
когда клавиша Tab (или что-то аналогичное) используется для переключения между элементами.
 То есть: если у нас два элемента, первый имеет tabindex="1", а второй tabindex="2", то находясь в первом элементе
и нажав Tab – мы переместимся во второй.
 Порядок перебора таков: сначала идут элементы со значениями tabindex от 1 и выше, в порядке tabindex,
а затем элементы без tabindex (например, обычный <input>).

 · tabindex="0" ставит элемент в один ряд с элементами без tabindex. То есть, при переключении такие элементы будут
  после элементов с tabindex ≥ 1.
 Обычно используется, чтобы включить фокусировку на элементе, но не менять порядок переключения.
 Чтобы элемент мог участвовать в форме наравне с обычными <input>.
 · tabindex="-1" позволяет фокусироваться на элементе только программно. Клавиша Tab проигнорирует такой элемент,
  но метод elem.focus() будет действовать.
* Кликни на первый пункт в списке и нажмите Tab


* События focusin/focusout
! События focus и blur не всплывают.
 Нельзя использовать onfocus на <form>, чтобы подсветить её. Смотри html id="formFocusOne".
Пример не работает, потому что когда пользователь перемещает фокус на <input>, событие focus срабатывает только на этом элементе. 
 У этой проблемы два решения.
 Первое: focus/blur не всплывают, но передаются вниз на фазе перехвата(последний аргумент true). id="formFocusTwo".
*/
formFocusTwo.addEventListener("focus", () => formFocusTwo.classList.add('focused'), true);
formFocusTwo.addEventListener("blur", () => formFocusTwo.classList.remove('focused'), true);
/*
 Второе решение: события focusin и focusout – такие же, как и focus/blur, но они всплывают.
! Эти события должны использоваться с elem.addEventListener, а не с on<event>.
*/

warn("======== События: change, input, cut, copy, paste ========");
/*
* Событие: change
 Событие change срабатывает по окончании изменения элемента.
Для текстовых <input> это означает, что событие происходит при потере фокуса.
Для других элементов: select, input type=checkbox/radio событие запускается сразу после изменения значения.
 Примеры в html.

 
* Событие: input
..срабатывает каждый раз при изменении значения.
 В отличие от событий клавиатуры, оно работает при любых изменениях значений, даже если они не связаны
с клавиатурными действиями: вставка с помощью мыши или распознавание речи при диктовке текста.
*/
changeInput.oninput = function () {
   spanResult.innerHTML = this.value;
}
//! Событие input происходит после изменения значения, поэтому не получится использовать event.preventDefault().

/*
* События: cut, copy, paste
Они относятся к классу ClipboardEvent и обеспечивают доступ к копируемым/вставляемым данным.
! Можно использовать event.preventDefault() для предотвращения действия по умолчанию.
*/
ccp.oncut = ccp.oncopy = ccp.onpaste = function (e) {
   alert(e.type + ' - ' + e.clipboardData.getData('text/plain'));
   return false;
};
//! Во всех браузерах, кроме Firefox запрещается генерировать «пользовательские» события буфера обмена при помощи dispatchEvent.
/*
Событие           \	Описание                         	           \  Особенности
___________________________________________________________________________________________________________________________
change	         \  Значение было изменено.	                       \  Для текстовых полей срабатывает при потере фокуса.
---------------------------------------------------------------------------------------------------------------------------
input	            \  Срабатывает при каждом изменении значения.	  \  Запускается немедленно, в отличие от change.
---------------------------------------------------------------------------------------------------------------------------
cut/copy/paste	   \  Действия по вырезанию/копированию/вставке.	  \  Действие можно предотвратить. 
                                                                    \ Свойство event.clipboardData предоставляет доступ на 
                                                                    \ чтение/запись в буфер обмена…
*/


warn("======== Отправка формы: событие и метод submit ========");
/*
 При отправке формы срабатывает событие submit, оно обычно используется для проверки (валидации) формы
перед её отправкой на сервер или для предотвращения отправки и обработки её с помощью JavaScript.
 Метод form.submit() позволяет инициировать отправку формы из JavaScript.

 
* Событие: submit
 Есть два основных способа отправить форму:
 · нажать кнопку <input type="submit"> или <input type="image">.
 · нажать Enter, находясь на каком-нибудь поле.
 Оба действия сгенерируют событие submit на форме. Обработчик может проверить данные, и если есть ошибки,
показать их и вызвать event.preventDefault(), тогда форма не будет отправлена на сервер. (пример в html)


* Взаимосвязь между submit и click
 При отправке формы по нажатию Enter в текстовом поле, генерируется событие click на кнопке <input type="submit">.
Это необычно, т.к. никакого клика не было. (пример в html)


* Метод: submit
 Чтобы отправить форму на сервер вручную, можно вызвать метод form.submit(). При этом событие submit не генерируется.
Предполагается, что если программист вызывает метод form.submit(), то он уже выполнил всю соответствующую обработку.
 Иногда это используют для генерации формы и отправки её вручную, например так:
*/
let formSub = document.createElement('form');
formSub.action = 'https://google.com/search';
formSub.metod = 'GET';

formSub.innerHTML = '<input name="q" value="test"';
document.body.append(formSub);
// formSub.submit(); // переход на страницу гугла




