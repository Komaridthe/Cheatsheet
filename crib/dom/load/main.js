let { warn } = console;


warn("=== DOMContentLoaded, load, beforeunload, unload ===");
/*
* У жизненного цикла HTML-страницы есть три важных события:
 · DOMContentLoaded – браузер полностью загрузил HTML, было построено DOM-дерево, но внешние ресурсы, такие как картинки <img> и стили,
  могут быть ещё не загружены.
 · load – браузер загрузил HTML и внешние ресурсы (картинки, стили и т.д.).
 · beforeunload/unload – пользователь покидает страницу.

 Каждое из этих событий может быть полезно:
 · Событие DOMContentLoaded – DOM готов, так что обработчик может искать DOM-узлы и инициализировать интерфейс.
 · Событие load – внешние ресурсы были загружены, стили применены, размеры картинок известны и т.д.
 · Событие beforeunload – пользователь покидает страницу. Мы можем проверить, сохранил ли он изменения и спросить,
  на самом ли деле он хочет уйти.
 · unload – пользователь почти ушёл, но мы всё ещё можем запустить некоторые операции, например, отправить статистику.


* DOMContentLoaded
 Событие DOMContentLoaded срабатывает на объекте document.
Необходимо использовать addEventListener, чтобы поймать его.
*/
function ready() {
   console.log('DOM загружен!');
   // изображение ещё не загружено (если не было закешировано), так что размер будет 0x0, если заранее не пропитать размер в CSS
   console.log(`Размер изображения: ${img.offsetWidth}x${img.offsetHeight}`); // что-то не так.. выдаёт полный размер
}
document.addEventListener('DOMContentLoaded', ready);

/*
* DOMContentLoaded и скрипты
 Когда браузер обрабатывает HTML-документ и встречает тег <script>, он должен выполнить его перед тем, как продолжить строить DOM.
Это делается на случай, если скрипт захочет изменить DOM или даже дописать в него (document.write),
так что DOMContentLoaded должен подождать.
 Поэтому DOMContentLoaded определённо случится после скриптов(см. html).
Сначала увидим «Библиотека загружена…», а затем «DOM готов!» (все скрипты выполнены).


! Есть два исключения из этого правила:
 · Скрипты с атрибутом async, не блокируют DOMContentLoaded.
 · Скрипты, сгенерированные динамически при помощи document.createElement('script') и затем добавленные на страницу,
  также не блокируют это событие.


* DOMContentLoaded и стили
 Внешние таблицы стилей не затрагивают DOM, поэтому DOMContentLoaded их не ждёт.
Но здесь есть подводный камень. Если после стилей у нас есть скрипт, то этот скрипт должен дождаться, пока загрузятся стили.

<link type="text/css" rel="stylesheet" href="style.css">

<script>        скрипт не выполняется, пока не загрузятся стили
  alert(getComputedStyle(document.body).marginTop);
</script>

 Причина в том, что скрипту может понадобиться получить координаты или другие свойства элементов, зависящих от стилей.


* window.onload
Событие load на объекте window наступает, когда загрузилась вся страница, включая стили, картинки и другие ресурсы (см. html).


* window.onunload
 Когда посетитель покидает страницу, на объекте window генерируется событие unload. В этот момент стоит совершать простые действия,
не требующие много времени, вроде закрытия связанных всплывающих окон. Обычно здесь отсылают статистику.
 Предположим, мы собрали данные о том, как используется страница: клики, прокрутка, просмотры областей страницы и так далее.
Естественно, событие unload – это тот момент, когда пользователь нас покидает и мы хотим сохранить эти данные.
 Для этого существует специальный метод navigator.sendBeacon(url, data). Он посылает данные в фоне.
Переход к другой странице не задерживается: браузер покидает страницу, но всё равно выполняет sendBeacon.
*/
let analiticsData = { /* объект с собранными данными */ };
window.addEventListener('unload', () => {
   navigator.sendBeacon('/analitics', JSON.stringify(analiticsData));
});
/*
 · Отсылается POST-запрос.
 · Мы можем послать не только строку, но так же формы и другие форматы, но обычно это строковый объект.
 · Размер данных ограничен 64 Кб.

 К тому моменту, как sendBeacon завершится, браузер наверняка уже покинет страницу, так что возможности обработать ответ сервера не будет
(для статистики он обычно пустой).
 Для таких запросов с закрывающейся страницей есть специальный флаг keepalive в методе fetch для общих сетевых запросов.


* window.onbeforeunload
 Если посетитель собирается уйти со страницы или закрыть окно, обработчик beforeunload попросит дополнительное подтверждение.
Если отменить это событие, то браузер спросит посетителя, уверен ли он (например, есть несохранённые изменения).
 Можно проверить это, запустив следующий код и затем перезагрузив страницу:
*/
window.onbeforeunload = function () {
   return false;
};

/*
* readyState
 Есть случаи, когда мы не уверены, готов документ или нет. Мы бы хотели, чтобы наша функция исполнилась, когда DOM загрузился,
будь то сейчас или позже. Свойство document.readyState показывает нам текущее состояние загрузки.
 Есть три возможных значения:
 · loading – документ загружается.
 · interactive – документ был полностью прочитан.
 · complete – документ был полностью прочитан и все ресурсы (такие как изображения) были тоже загружены.

 С помошью document.readyState можно либо установить обработчик, либо, если документ готов, выполнить код сразу же.
*/
function work() { console.log('Hello!'); }

if (document.readyState == 'loading') {
   // ещё загружается, ждём события
   document.addEventListener('DOMContentLoaded', work);
} else {
   // DOM готов!
   console.log('DOM загружен, запускаю функцию!');
   work();
}

/*
* readystatechange
 Событие readystatechange, генерируется при изменении состояния, так что мы можем вывести все эти состояния таким образом:
*/
console.log(document.readyState);
document.addEventListener('readystatechange', () => console.log(document.readyState));
// Событие readystatechange – альтернативный вариант отслеживания состояния загрузки документа. 
// На сегодняшний день он используется редко.



warn("======== async, defer ========");
/*
 Это два отрибута тега <script>, позволяющие разработчикам оходить проблемs при загрузке html.

* defer
 Атрибут defer сообщает браузеру, что он должен продолжать обрабатывать страницу и загружать скрипт в фоновом режиме,
а затем запустить этот скрипт, когда DOM дерево будет полностью построено. Примеир в html.
 · Скрипты с defer никогда не блокируют страницу.
 · Скрипты с defer всегда выполняются, когда дерево DOM готово, но до события DOMContentLoaded.
 · Отложенные с помощью defer скрипты сохраняют порядок относительно друг друга, как и обычные скрипты.
  Поэтому, если сначала загружается большой скрипт, а затем меньшего размера, то последний будет ждать.

! Атрибут defer предназначен только для внешних скриптов, он будет проигнорирован, если в теге <script> нет src.

* async
Атрибут async означает, что скрипт абсолютно независим:
 · Страница не ждёт асинхронных скриптов, содержимое обрабатывается и отображается.
 · Событие DOMContentLoaded и асинхронные скрипты не ждут друг друга:
  · DOMContentLoaded может произойти как до асинхронного скрипта 
  (если асинхронный скрипт завершит загрузку после того, как страница будет готова),
  · …так и после асинхронного скрипта (если он короткий или уже содержится в HTTP-кеше)
 · Остальные скрипты не ждут async, и скрипты casync не ждут другие скрипты.


* Динамически загружаемые скрипты
Добавление скрипта и динамически, с помощью JavaScript:
*/
let script = document.createElement('script');
script.src = "/article/script-async-defer/long.js";
document.body.append(script);

//! Динамически загружаемые скрипты по умолчанию ведут себя как «async».
/*
 Мы можем изменить относительный порядок скриптов с «первый загрузился – первый выполнился» на порядок, 
в котором они идут в документе (как в обычных скриптах) с помощью явной установки свойства async в false.
*/
script.async = false; // прописать до добавления на страницу
/*
 Например, здесь мы добавляем два скрипта. Без script.async=false они запускались бы в порядке загрузки 
(small.js скорее всего запустился бы раньше). Но с этим флагом порядок будет как в документе:
*/
function loadScript(src) {
   let script = document.createElement('script');
   script.src = src;
   script.async = false;
   document.body.append(script);
}
// long.js запускается первым, так как async=false
loadScript("/article/script-async-defer/long.js");
loadScript("/article/script-async-defer/small.js");


warn("======== Загрузка ресурсов: onload и onerror ========");
/*
 Браузер позволяет отслеживать загрузку сторонних ресурсов: скриптов, ифреймов, изображений и др.
Для этого существуют два события:
 · load – успешная загрузка,
 · error – во время загрузки произошла ошибка.

* Загрузка скриптов
 Допустим, нужно загрузить сторонний скрипт и вызвать функцию, которая объявлена в этом скрипте.
Мы можем загрузить этот скрипт динамически:
*/
let scriptOne = document.createElement('script');
scriptOne.src = "my.js";
document.head.append(scriptOne);
/*
 …Но как нам вызвать функцию, которая объявлена внутри того скрипта? Нам нужно подождать, пока скрипт загрузится,
и только потом мы можем её вызвать.

* script.onload
Событие load срабатывает после того, как скрипт был загружен и выполнен.
*/
let scriptTwo = document.createElement('script');
scriptTwo.src = "https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.3.0/lodash.js";
document.head.append(scriptTwo);

scriptTwo.onload = function () {
   // в скрипте создаётся вспомогательная переменная с именем "_"
   console.log(_.VERSION); // отображает версию библиотеки
}
/*
 Таким образом, в обработчике onload мы можем использовать переменные, вызывать функции и т.д.,
которые предоставляет нам сторонний скрипт.

* script.onerror
 Ошибки, которые возникают во время загрузки скрипта, могут быть отслежены с помощью события error.
Пример скрипта, которого н есуществует:
*/
let scriptErr = document.createElement('script');
scriptErr.src = "https://example.com/404.js"; // такого файла не существует
document.head.append(scriptErr);

scriptErr.onerror = function () {
   console.log("Ошибка загрузки " + this.src); // Ошибка загрузки https://example.com/404.js
};
/*
! Нельзя получить описание HTTP-ошибки. Неизвестно, была ли это ошибка 404 или 500, или какая-то другая.
! Известно только, что во время загрузки произошла ошибка.
 Ошибки обработки и выполнения загруженного скрипта onload/onerror не отслеживаются. Чтобы «поймать» ошибки в скрипте,
нужно воспользоваться глобальным обработчиком window.onerror.


* Другие ресурсы
 События load и error также срабатывают и для других ресурсов, а вообще, для любых ресурсов, у которых есть внешний src.
*/
let img = document.createElement('img');
img.src = "https://js.cx/clipart/train.gif";

img.onload = function () {
   console.log(`Изображение загружено, его размеры ${img.width}x${img.height}`);
};
img.onerror = function () {
   console.log("Ошибка во время загрузки изображения");
};
/*
 Однако есть некоторые особенности:
 · Большинство ресурсов начинают загружаться после их добавления в документ. За исключением тега <img>.
  Изображения начинают загружаться, когда получают src (*).
 · Для <iframe> событие load срабатывает по окончании загрузки как в случае успеха, так и в случае ошибки.


* Ошибка в скрипте с другого источника
 Есть правило: скрипты с одного сайта не могут получить доступ к содержимому другого сайта.
 Или, если быть более точным, один источник (домен/порт/протокол) не может получить доступ к содержимому с другого источника.
Даже поддомен или просто другой порт будут считаться разными источниками, не имеющими доступа друг к другу.
 Любая информация о внутреннем устройстве скрипта, включая стек ошибки, спрятана.

* Чтобы разрешить кросс-доменный доступ, нам нужно поставить тегу <script> атрибут crossorigin,
* и, кроме того, удалённый сервер должен поставить специальные заголовки.
 Существует три уровня кросс-доменного доступа:
 · Атрибут crossorigin отсутствует – доступ запрещён.
 · crossorigin="anonymous" – доступ разрешён, если сервер отвечает с заголовком Access-Control-Allow-Origin
  со значениями * или наш домен. Браузер не отправляет авторизационную информацию и куки на удалённый сервер.
 · crossorigin="use-credentials" – доступ разрешён, если сервер отвечает с заголовками Access-Control-Allow-Origin
  со значением наш домен и Access-Control-Allow-Credentials: true. Браузер отправляет авторизационную информацию и куки на удалённый сервер.
*/


