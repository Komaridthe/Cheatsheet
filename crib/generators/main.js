let { warn } = console;


warn('=========== Генераторы ===========');
/*
 Генераторы это функции которые могут возвращать множество значений одно за другим,
по мере необходимости.

* Функция-генератор
*/
// Синтаксическая конструкция: function*
function* generateSequence() {
   yield 1;
   yield 2;
   return 3;
};
/*
 Когда такая функция вызвана, она не выполняет свой код. Вместо этого она возвращает специальный объект,
так называемый «генератор», для управления её выполнением.
*/
let generator = generateSequence();
console.log(generator);

/*
* next()
 Является основным методом генератора. При вызове он запускает выполнение кода до ближайшей инструкции yield <значение>.
По достижении yield выполнение функции приостанавливается до следующего вызова next().

 Результатом метода next() всегда является объект с двумя свойствами:
 · value: значение из yield.
 · done: true, если выполнение функции завершено, иначе false.
*/
let one = generator.next();
console.log(one); // {value: 1, done: false}
// Получено только первое значение, выполнение функции остановлено на второй строке.

// Повторный вызов generator.next() возобновит выполнение кода и вернёт результат следующего yield.
let two = generator.next();
console.log(two); // {value: 2, done: false}

// Последний вызов завершит выполнение функции и вернёт результат return.
let three = generator.next();
console.log(three); // {value: 3, done: true}
/*
 Генератор полностью выполнен, это видно по свойству done:true.
Новые вызовы generator.next() больше не имеют смысла. Они не вызовут ошибки, а будут возвращать
один и тот же объект: {value: undefined, done: true}.
*/


warn('============ Перебор генераторов ============');
/*
 Генераторы являются перебираемыми объектами.
Возвращаемые ими значения можно перебирать через for..of:
*/
function* genNum() {
   yield 1;
   yield 2;
   return 3;
};
let gen = genNum();

for (const value of gen) {
   console.log(value); // 1, затем 2
};
/*
! Значение 3 выведено не будет!
 Это из-за того, что перебор через for..of игнорирует последнее значение, при котором done: true.
Поэтому, если необходимо, чтобы были все значения при переборе через for..of, то надо возвращать их через yield.
*/
function* genNumTwo() {
   yield 1;
   yield 2;
   yield 3;
};
let genTwo = genNumTwo();

for (const value of genTwo) {
   console.log(value); // 1, затем 2, затем 3
};
/*
 Так как генераторы являются перебираемыми объектами, можно использовать всю связанную с ними функциональность,
например оператор расширения ...
*/
let sequence = [0, ...genNumTwo()];
console.log(sequence); // [0, 1, 2, 3]


warn('== Использование генераторов для перебираемых объектов ==');
/*
 Чтобы объект range стал итерабельным ему неоходимо присвоить символ [Symbol.iterator], который 
позволит возвращать значения from..to.
*/
let range = {
   from: 1,
   to: 5,

   [Symbol.iterator]() {
      return {
         current: this.from,
         last: this.to,

         next() { // next() вызывается при каждой итерации цикла for..of
            if (this.current <= this.last) {
               return { value: this.current++, done: false };
            } else {
               return { value: undefined, done: true };
            }
         }
      };
   }
};
// при переборе объекта range будут выведены числа от range.from до range.to
console.log([...range]); // [1, 2, 3, 4, 5]

// Для сокращения кода можно использовать функцию-генератор для итерации, указав её в Symbol.iterator.
let rangeTwo = { // Тот же range, но с гораздо более компактным итератором
   from: 1,
   to: 5,

   *[Symbol.iterator]() { // краткая запись для [Symbol.iterator]: function*()
      for (let value = this.from; value <= this.to; value++) {
         yield value;
      }
   }
};
console.log([...rangeTwo]); // [1, 2, 3, 4, 5]
/*
 Это работает, потому что range[Symbol.iterator]() теперь возвращает генератор,
и его методы – в точности то, что ожидает for..of:
 · у него есть метод .next()
 · который возвращает значения в виде {value: ..., done: true/false}
*/

warn('========== Композиция генераторов ===========');
/*
 Это особенная возможность генераторов, которая позволяет прозрачно «встраивать» генераторы друг в друга.
Например, у имеется функция для генерации последовательности чисел:
*/
function* genSequence(start, end) {
   for (let i = start; i <= end; i++) yield i;
};
/*
 Задача - использовать её при генерации более сложной последовательности:
 · сначала цифры 0..9 (с кодами символов 48…57)
 · за которыми следуют буквы в верхнем регистре A..Z (коды символов 65…90)
 · за которыми следуют буквы алфавита a..z (коды символов 97…122)

 Можно использовать такую последовательность для генерации паролей, выбирать символы из неё,
но сначала её нужно сгенерировать.
 Для генераторов есть особый синтаксис yield*, который позволяет «вкладывать» генераторы
один в другой (осуществлять их композицию).
*/
function* generatePasswordCodes() {
   yield* genSequence(48, 57); // 0..9
   yield* genSequence(65, 90); // A..Z
   yield* genSequence(97, 122); // a..z
};

let str = '';

for (let code of generatePasswordCodes()) {
   str += String.fromCharCode(code);
};
console.log(str); // 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz
/*
 Директива yield* делегирует выполнение другому генератору. Это означает, что yield* gen
перебирает генератор gen и прозрачно направляет его вывод наружу. Как если бы значения были
сгенерированы внешним генератором.
 Композиция генераторов не использует дополнительную память для хранения промежуточных результатов.
*/

warn('======== yield – дорога в обе стороны ========');
/*
 yield не только возвращает результат наружу, но и может передавать значение извне в генератор.
Чтобы это сделать, нужно вызвать generator.next(arg) с аргументом.
Этот аргумент становится результатом yield.
*/
function* gener() {
   let result = yield "2 + 2 = ?"; // Передаём вопрос во внешний код и ожидаем ответа
   console.log(result);
};
let genFour = gener();
let qestion = genFour.next().value; // yield возвращает значение (qestion = "2 + 2 = ?")
genFour.next(4); // передаём результат в генератор (next(4) -> result)
/*
 1) Первый вызов generator.next() – всегда без аргумента, он начинает выполнение и возвращает результат
 первого yield "2+2=?". На этой точке генератор приостанавливает выполнение.
 2) Затем результат yield переходит во внешний код в переменную question.
 3) При generator.next(4) выполнение генератора возобновляется, а 4 выходит из присваивания
 как результат: let result = 4.
*/
//* Пример с большим количеством вызовов
function* askGen() {
   let ask1 = yield "2 + 2 = ?";
   console.log(ask1); // 4
   let ask2 = yield "3 + 3 = ?";
   console.log(ask2); // 6
};
let generatorAsk = askGen();
console.log(generatorAsk.next().value); // 2 + 2 = ?
console.log(generatorAsk.next(4).value); // 3 + 3 = ?
console.log(generatorAsk.next(6).done); // true
/*
 1) Первый .next() начинает выполнение… Оно доходит до первого yield.
 2) Результат возвращается во внешний код.
 3) Второй .next(4) передаёт 4 обратно в генератор как результат первого yield и возобновляет выполнение.
 4) …Оно доходит до второго yield, который станет результатом .next(4).
 5) Третий next(9) передаёт 9 в генератор как результат второго yield и возобновляет выполнение,
 которое завершается окончанием функции, так что done: true.

 Каждый next(value) передаёт в генератор значение, которое становится результатом текущего yield,
возобновляет выполнение и получает выражение из следующего yield.
*/

warn('========= generator.throw ==========');
/*
 В генератор можно передать не только результат, но и инициировать ошибку.
Для того, чтобы передать ошибку в yield, нужно вызвать generator.throw(err).
В таком случае исключение err возникнет на строке с yield.

 Здесь yield "2 + 2 = ?" приведёт к ошибке:
*/
function* errGen() {
   try {
      let result = yield "2 + 2 = ?";
      console.log(result);
   } catch (err) {
      console.log(err); // Ответ не найден в базе данных!
   }
};
let errGenerator = errGen();
errGenerator.next().value;
errGenerator.throw(new Error("Ответ не найден в базе данных!"));
/*
 Если не перехватывать ошибку, то она, как и любое обычное исключение, «вывалится» из генератора
во внешний код.
 Текущая строка вызывающего кода – это строка с generator.throw. Таким образом, можно отловить её
во внешнем коде, вот так:
*/
function* errGenTwo() {
   let result = yield "2 + 2 = ?";
};
let errGeneratorTwo = errGenTwo();
errGeneratorTwo.next().value;
try {
   errGeneratorTwo.throw(new Error("Ответ не найден в базе данных!"));
} catch (e) {
   console.log(e);
};


warn('==== Асинхронные итераторы и генераторы ====');
/*
 Асинхронные итераторы позволяют перебирать данные, поступающие асинхронно. Например, когда загружается
что-то по частям по сети.
 Асинхронные генераторы делают такой перебор ещё удобнее.

* Асинхронные итераторы
 Асинхронные итераторы похожи на обычные итераторы, но имеют некоторые синтаксические отличия.
«Обычный» перебираемый объект есть на стоке №94.

 Чтобы сделать объект итерируемым асинхронно:
 · Используется Symbol.asyncIterator вместо Symbol.iterator.
 · next() должен возвращать промис.
 · Чтобы перебрать такой объект, используется цикл for await (let item of iterable).
*/
let asyncRange = {
   from: 11,
   to: 15,

   [Symbol.asyncIterator]() {
      return {
         current: this.from,
         last: this.to,

         async next() { // next() вызывается на каждой итерации цикла for await..of
            await new Promise(resolve => setTimeout(resolve, 1000)); // await для асинхронности

            if (this.current <= this.last) {
               return { value: this.current++, done: false };
            } else {
               return { value: undefined, done: true };
            }
         }
      };
   }
};
(async () => {
   for await (let value of asyncRange) {
      console.log(value); // 11,12,13,14,15 с задержкой в секунду
   }
})()
/*
 Структура похожа на обычные итераторы:
 · Чтобы сделать объект асинхронно итерируемым, он должен иметь метод Symbol.asyncIterator.
 · Этот метод должен возвращать объект с методом next(), который в свою очередь возвращает промис.
 · Метод next() не обязательно должен быть async, он может быть обычным методом, возвращающим промис,
  но async позволяет использовать await, так что это удобно. В примере просто делаем паузу на одну секунду.
 · Для итерации используется for await (let value of range), добавляя «await» после «for».
  Он вызовет range[Symbol.asyncIterator]() один раз, а затем его метод next() для получения значений.

                                                         \  Итераторы	             \  Асинхронные итераторы
_________________________________________________________\___________________________\__________________________
Метод для создания итерируемого объекта	               \  Symbol.iterator	       \  Symbol.asyncIterator
---------------------------------------------------------\---------------------------\--------------------------
next() возвращает	                                       \  любое значение	          \  промис
---------------------------------------------------------\---------------------------\--------------------------
для цикла использовать	                                 \  for..of	                \  for await..of
---------------------------------------------------------------------------------------------------------------
*/

//* Асинхронные генераторы
/*
 В обычных генераторах нельзя использовать await. Все значения должны поступать синхронно: 
в for..of нет места для задержки, это синхронная конструкция.
 Чтобы генератор стал асинхронным нужно просто написать перед ним async.
*/
async function* asyncGen(start, end) {
   for (let i = start; i <= end; i++) {
      await new Promise(r => setTimeout(r, 1000));
      yield i;
   }
};
(async () => {
   let asyncGenerator = asyncGen(1, 5);
   for await (let value of asyncGenerator) {
      console.log(value); // 1,2,3,4,5 с задержкой в секунду
   }
})();
/*
 С технической точки зрения, ещё одно отличие асинхронного генератора заключается в том,
что его метод asyncGenerator.next() теперь тоже асинхронный и возвращает промисы.
 Из обычного генератора мы можем получить значения при помощи result = generator.next().
Для асинхронного нужно добавить await, вот так:

result = await generator.next(); // result = {value: ..., done: true/false}

* Асинхронно перебираемые объекты
 Чтобы добавить объекту асинхронные действия в генератор, нужно заменить Symbol.iterator
на асинхронный Symbol.asyncIterator.
*/
let asyncRangeGen = {
   from: 111,
   to: 115,

   async *[Symbol.asyncIterator]() {
      for (let i = this.from; i <= this.to; i++) {
         await new Promise(r => setTimeout(r, 1000));
         yield i;
      }
   }
};
(async()=>{
   for await(const i of asyncRangeGen) {
      console.log(i); // 111 ,112, 113, 114, 115 с интервалом в секунду
   }
})(); // Теперь значения поступают с задержкой в одну секунду между ними.

/*
                             \  Генераторы	               \  Асинхронные генераторы
_____________________________\______________________________\____________________________________________________________
Объявление                   \  function       	            \  async funtion*
-----------------------------\------------------------------\------------------------------------------------------------
генератор next() возвращает  \  {value:…, done: true/false} \  промис, который завершается с {value:…, done: true/false}
-----------------------------\------------------------------\------------------------------------------------------------
*/


