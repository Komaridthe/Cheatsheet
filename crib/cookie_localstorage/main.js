let { warn } = console;

warn("======== Cookie ========");
//* Чтение из document.cookie
// Значение document.cookie состоит из пар ключ=значение, разделённых ;. Каждая пара представляет собой отдельное куки.
console.log(document.cookie);
/*
* Запись в document.cookie
 Мы можем писать в document.cookie. Но это не просто данные, а акcессор (геттер/сеттер). Присваивание обрабатывается особым образом.
Запись в document.cookie обновит только упомянутые в ней куки, но при этом не затронет все остальные.
*/
document.cookie = "user=John"; // обновляем только куки с именем 'user'
console.log(document.cookie);
/*
 Технически, и имя и значение куки могут состоять из любых символов, для правильного форматирования следует использовать
встроенную функцию encodeURIComponent:
*/
// специальные символы (пробелы), требуется кодирование
let name = "my name";
let value = "John Smith";

// кодирует в my%20name=John%20Smith
document.cookie = encodeURIComponent(name) + "=" + encodeURIComponent(value);
console.log(document.cookie); // ...; my%20name=John%20Smith
/*
* Существует несколько ограничений:
 · После encodeURIComponent пара name=value не должна занимать более 4Кб. Таким образом, мы не можем хранить в куки большие данные.
 · Общее количество куки на один домен ограничивается примерно 20+. Точное ограничение зависит от конкретного браузера.


* Настройки
* path
path=/mypath
 URL-префикс пути, куки будут доступны для страниц под этим путём. Должен быть абсолютным. По умолчанию используется текущий путь.
Если куки установлено с path=/admin, то оно будет доступно на страницах /admin и /admin/something, но не на страницах /home или /adminpage.
Как правило, указывают в качестве пути корень path=/, чтобы наше куки было доступно на всех страницах сайта.

* domain
domain=site.com
 Домен, на котором доступны наши куки. На практике, однако, есть ограничения – мы не можем указать здесь какой угодно домен.
По умолчанию куки доступно лишь тому домену, который его установил. Так что куки, которые были установлены сайтом site.com,
не будут доступны на сайте other.com.
!…Но что более интересно, мы не сможем получить эти куки на поддомене forum.site.com!

* expires, max-age
 По умолчанию, если куки не имеют ни одного из этих параметров, то они удалятся при закрытии браузера.
Такие куки называются сессионными («session cookies»).
 Чтобы помочь куки «пережить» закрытие браузера, мы можем установить значение опций expires или max-age.
expires=True, 19 Jan 2038 03:14:07 GMT
 Дата истечения срока действия куки, когда браузер удалит его автоматически.
*/
// +1 день от текущей даты
let date = new Date(Date.now() + 86400e3);
date = date.toUTCString();
document.cookie = "user=John; expires=" + date;

// Если задан ноль или отрицательное значение, то куки будет удалено:
// куки будет удалено через 1 час
document.cookie = "user=John; max-age=3600";

// удалим куки (срок действия истекает прямо сейчас)
document.cookie = "user=John; max-age=0";
/*
* secure
 Куки следует передавать только по HTTPS-протоколу.
По умолчанию куки, установленные сайтом http://site.com, также будут доступны на сайте https://site.com и наоборот.

 предполагается, что сейчас мы на https://
установим опцию secure для куки (куки доступно только через HTTPS)
*/
document.cookie = "user=John; secure";
/*
* samesite
 Это ещё одна настройка безопасности, применяется для защиты от так называемой XSRF-атаки.
У него есть два возможных значения:
 · samesite=strict (или, что то же самое, samesite без значения)
  Куки с samesite=strict никогда не отправятся, если пользователь пришёл не с этого же сайта.
 · samesite=lax
  Режим Lax так же, как и strict, запрещает браузеру отправлять куки, когда запрос происходит не с сайта, но добавляет одно исключение:
 Куки с samesite=lax отправляется, если два этих условия верны:
 · Используются безопасные HTTP-методы (например, GET, но не POST).
 · Операция осуществляет навигацию верхнего уровня (изменяет URL в адресной строке браузера)...(не <iframe>)
*/

warn("======== LocalStorage, sessionStorage ========");
/*
* Объекты веб-хранилища localStorage и sessionStorage позволяют хранить пары ключ/значение в браузере.
 · key и value должны быть строками.
 · Лимит 2 Мб+, зависит от браузера.
 · Данные не имеют «времени истечения».
 · Данные привязаны к источнику (домен/протокол/порт).

localStorage	                                          \ sessionStorage
_________________________________________________________\_________________________________
 Совместно используется между всеми вкладками            \ Разделяется в рамках вкладки браузера,
и окнами с одинаковым источником	                        \ среди ифреймов из того же источника
---------------------------------------------------------\-----------------------------------------
«Переживает» перезапуск браузера	                        \ «Переживает» перезагрузку страницы 
                                                         \ (но не закрытие вкладки)

 API:
 · setItem(key, value) – сохранить пару ключ/значение.
 · getItem(key) – получить данные по ключу key.
 · removeItem(key) – удалить значение по ключу key.
 · clear() – удалить всё.
 · key(index) – получить ключ на заданной позиции.
 · length – количество элементов в хранилище.
 · Используйте Object.keys для получения всех ключей.
 · Можно обращаться к ключам как к обычным свойствам объекта, в этом случае событие storage не срабатывает.

 * Доступ как к обычному объекту
Также можно получать/записывать данные, как в обычный объект:
*/
localStorage.test = 2;
// получить значение по ключу
console.log(localStorage.test); // 2
// удалить ключ
delete localStorage.test;

/*
* Перебор ключей
 Объекты веб-хранилища нельзя перебрать в цикле, они не итерируемы.
Но можно пройти по ним, как по обычным массивам:
*/
for (let i = 0; i < localStorage.length; i++) {
  let key = localStorage.key(i);
  console.log(`${key}: ${localStorage.getItem(key)}`);
}

// Цикл for in, но без проверки выдаст и прототипные свойства
for (let key in localStorage) {
  console.log(key); // покажет getItem, setItem и другие встроенные свойства
}

// …Поэтому нам нужно либо отфильтровать поля из прототипа проверкой hasOwnProperty:
for (const key in localStorage) {
  if (!Object.hasOwnProperty(key)) continue;
  console.log(`${key}: ${localStorage.getItem(key)}`);
}

// …либо просто получить «собственные» ключи с помощью Object.keys, а затем при необходимости вывести их при помощи цикла:
let keys = Object.keys(localStorage);
for (let key of keys) {
  console.log(`${key}: ${localStorage.getItem(key)}`);
}
/*
! Ключ и значение должны быть строками.
Если мы используем любой другой тип, например число или объект, то он автоматически преобразуется в строку:
*/
sessionStorage.user = { name: "John" };
console.log(sessionStorage.user); // [object Object]

// Можно использовать JSON для хранения объектов:
sessionStorage.user = JSON.stringify({ name: "John" });

let user = JSON.parse(sessionStorage.user);
console.log(sessionStorage.user); // {"name":"John"}
/*
* sessionStorage
 Свойства и методы такие же, но есть существенные ограничения:
 · sessionStorage существует только в рамках текущей вкладки браузера.
  · Другая вкладка с той же страницей будет иметь другое хранилище.
  · Но оно разделяется между iframe на той же вкладке (при условии, что они из одного и того же источника).
 · Данные продолжают существовать после перезагрузки страницы, но не после закрытия/открытия вкладки.


* Событие storage
К огда обновляются данные в localStorage или sessionStorage, генерируется событие storage со следующими свойствами:
 · key – ключ, который обновился (null, если вызван .clear()).
 · oldValue – старое значение (null, если ключ добавлен впервые).
 · newValue – новое значение (null, если ключ был удалён).
 · url – url документа, где произошло обновление.
 · storageArea – объект localStorage или sessionStorage, где произошло обновление.
! Важно: событие срабатывает на всех остальных объектах window, где доступно хранилище, кроме того окна, которое его вызвало.


 В поле textarea, значение будет автоматически сохраняться при каждом его изменении.
Когда пользователь закроет страницу и потом откроет её заново он увидет последнее введённое значение.
*/
area.value = localStorage.getItem("area");
area.oninput = () => {
  localStorage.setItem("area", area.value);
};

warn("======== IndexedDB ========");

console.error("Тему не подготовил!");
